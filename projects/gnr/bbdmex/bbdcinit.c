/* (c) Copyright 2007-2015, The Rockefeller University *11116* */
/* $Id: bbdcinit.c 17 2017-10-13 19:00:07Z  $ */
/***********************************************************************
*               BBD (Client Side) mex-Function Package                 *
*                             bbdcinit.c                               *
*         Initialize communication with a network simulation           *
*                                                                      *
*  This is the matlab mex-function version of bbdcinit().              *
*  This routine may be called by a MATLAB application to establish     *
*  communication with the cortical network simulator, CNS, in order    *
*  that CNS may provide network services for the application.  It is   *
*  assumed that inetd has been set up on the target system to listen   *
*  on the assigned port and start CNS when a request is received.      *
*  Child processes bbdcminp and bbdcmlog are executed from here.       *
*  The multiple-host BBD mechanism is not supported.                   *
*                                                                      *
*  MATLAB Synopsis:                                                    *
*  BBDComm = bbdcinit(cnsfile, logfile [, vardefs] [, retver [, host   *
*     [, port]]])                                                      *
*                                                                      *
*  Arguments:                                                          *
*     cnsfile  A string giving the name of a valid CNS control file.   *
*              This file will be read and presented to CNS on its      *
*              standard input.  It is assumed that this file will      *
*              contain all necessary parameters and options to set up  *
*              CNS appropriately for the application and will end with *
*              a CYCLE card that will allow CNS to run indefinitely    *
*              until stopped by a suitable event.  (If it contains an  *
*              EXECUTE card, the file to be executed must be access-   *
*              ible on the host where CNS is running.)                 *
*     logfile  Name of a file that can be opened for writing a log.    *
*              Because the BBD calling application has no use for any  *
*              printed output generated by CNS (which is under control *
*              of options in the cnsfile), bbdcinit() spawns a         *
*              subprocess that copies any such data to the specified   *
*              log file.  Writing commences at the start of the file,  *
*              destroying any previous data.  If logfile is an empty   *
*              string, the log data are discarded.                     *
*     vardefs  A MATLAB struct used to pass values for crk variable    *
*              symbols to the CNS control file.  For each variable to  *
*              be defined, add a member to the struct whose name is    *
*              the name of the variable to be defined, minus the lead- *
*              ing '%', and whose value is a MATLAB string giving the  *
*              value (numeric values must be converted to strings with *
*              sprintf or equivalent). This argument may be positioned *
*              anywhere in the argument list (it is the only struct).  *
*              Values are passed to CNS via an EXECUTE card prepended  *
*              to the control file contents.  (Current size limits are *
*              7 characters for variable names and 16 for characters.  *
*              These can be changed if needed.  The limit on the total *
*              size of all these arguments comes from the Linux kernel *
*              and is very large, at least 128K bytes.)                *
*     retver   [Optional double or int32 scalar] = +1 to return CNS    *
*              version information after the bbdcchk call.  This       *
*              information can be retrieved by a call to bbdcgetm.     *
*              +2 to omit setting up a bbdcminp log file in /var/tmp.  *
*              0 or missing argument to build log, omit sending        *
*              version information.                                    *
*     host     [Optional string]  A string giving the name of the host *
*              where the network simulation is to be run followed by a *
*              semicolon and the IP address or resolvable name of this *
*              client host.  An empty string or missing argument       *
*              indicates that the simulation is to be run on the       *
*              calling host.  (See note below.)                        *
*     port     [Optional double or int32 scalar]  Number of the port   *
*              to be used to initiate communication with CNS.  If      *
*              coded as 0 or missing argument, the default port taken  *
*              from the bbd.h header file will be used. The next       *
*              higher-numbered port will be used for data exchange.    *
*                                                                      *
*  Return value:                                                       *
*     BBDComm  A matlab array containing information used for communi- *
*              cation among the various routines in the bbdc package.  *
*              It must be passed as an argument in the calls to all    *
*              the other routines.  The contents are of no concern to  *
*              the matlab programmer and should not be modified.       *
*                                                                      *
*  Note re setup of second socket interface:                           *
*     Some thought was given to how one might automate the sending of  *
*  the correct callback IP address to CNS so manual intervention would *
*  not be required every time DHCP hands out a new host address.  How- *
*  ever, it was considered desirable to make this program as much as   *
*  possible independent of what OS it might be running, so the problem *
*  was pushed back to the caller via the requirement for both server   *
*  name and IP address in the 'host' argument.                         *
*                                                                      *
*  Error Handling:                                                     *
*     All errors are terminal and result in a call to abexitm() with a *
*  suitable message.  (A few errors that "should never happen" just    *
*  call abexit() with no message.)  There is nothing useful the caller *
*  can do.  This package includes versions of abexit(), abexitm(), and *
*  abexitme() that are designed to operate properly in the MATLAB      *
*  environment and to release mexMakeMemoryPersistent memory. However, *
*  the subprocesses spawned by bbdcinit must have separate versions to *
*  report their errors back to the parent process.                     *
*                                                                      *
*  Implementation Notes:                                               *
*     This program calls signal() to ignore SIGPIPE signals.  This is  *
*  to allow read() calls on the pipe to report errors, rather than     *
*  just get the application terminated (although the default action    *
*  according to one source at least, is ignore anyway).  Obviously,    *
*  if we eventually need a signal handler for some pipe signals and    *
*  not others, a more global way of controlling this will be needed.   *
*     Semaphores were added to allow bbdcchk to find out that either   *
*  of the subprocesses failed to start (missing executable)--the       *
*  BBDcd->Mlogrc test fails and rfopen() hangs forever if the bad      *
*  child process did not exit before the main process arrived at       *
*  bbdcchk().                                                          *
*     The vardefs argument is an improved version of the earlier       *
*  BBDCEXSI mechanism, which is retained for compatibility.            *
************************************************************************
*  This file also contains support routines bbdcquit and bbdcchldsig   *
*  which should not be called direcly by the BBD user.                 *
************************************************************************
*  V1A, 10/22/10, GNR - New mex version                                *
*  ==>, 11/04/10, GNR - Last mod before committing to svn repository   *
*  Rev, 11/05/10, GNR - Better error checking for bad child procs.     *
*  V1B, 01/13/11, GNR - Pass file descriptor for errors to bbdcminp    *
*  Rev, 04/18/13, GNR - Remove bbdcquit() to its own source file       *
*  Rev, 11/09/15, GNR - Add a wrapper for matlab debugging             *
*  R13, 11/15/15, GNR - Add 'vardefs' argument, more error codes       *
***********************************************************************/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <semaphore.h>

#define I_AM_MEX
#define MINP_LOG_FILE "/var/tmp/bbdcminp.log"

#include "mex.h"
#include "sysdef.h"
#include "bbd.h"
#include "rfdef.h"
#include "rksubs.h"

/* Definitions unique to this file */
#define MxInitArgs       6    /* Max args to mex bbdcinit */
#define NBaseMinpArgs    7    /* bbdcminp args besides vardefs */
/* N.B.  The following max lengths are derived from L_SYMBNM in
*  rockv.h and DFLT_MAXLEN in rocks.h (not included here because
*  those header files declare common blocks used by rocks library
*  functions).  If these limits need to be increased, rocks library
*  must be recompiled with corresponding increases in those limits
*  so the Cns server can handle the longer variables.  */
#define MxLSymbol       15    /* Max length of a symbol name */
#define MxLSValue      255    /* Max length of a symbol value */

static mxArray *BBDcdA;       /* Ptr to common BBD data struct */
enum minpargs { mnpnm, mnpsock, mnpinfd, mnpchnm, mnpvcli, mnpport,
   mnpxtra, mnpvard };
enum rhargs { jcnsf, jlogf, jretv, jhost, jport };

/*=====================================================================*
*                               bbdcqex                                *
*                                                                      *
*  This routine is registered via mexAtExit() to run when matlab       *
*  exits.  It locates the BBDComData array using the local static      *
*  common and calls bbdcquit() to shut down CNS if not already dead,   *
*  close files, release memory, and return to the regular shutdown     *
*  process.                                                            *
*=====================================================================*/

void bbdcqex(void) {

   struct BBDComData *DDBcd = mxGetData(BBDcdA);
   bbdcquit(DDBcd);
   mxDestroyArray(BBDcdA);

   } /* End bbdcqex() */

/*=====================================================================*
*                             bbdcchldsig                              *
*                                                                      *
*  Routine to handle a SIGCHLD received by the main process.  This     *
*  routine must distinguish between termination of the mlog vs minp    *
*  processes and set the appropriate flag in the BBDcd data structure  *
*  so the main program can quit at the next nondangerous location.     *
*  If it was some other process (part of Allegro?) this routine does   *
*  not do a wait on it so as not to interfere with code elsewhere.     *
*  Post semaphores so bbdcchk can proceed if waiting for subprocs but  *
*  ignore errors because this is a signal handler.                     *
*=====================================================================*/

static void bbdcchldsig(int signum) {

   struct BBDComData *BBDcd = mxGetData(BBDcdA);
   int status,rc;

   /* Was it the log process? */
   while (BBDcd->LogProc) {
      rc = waitpid(BBDcd->LogProc, &status, WNOHANG);
      if (rc == 0) break;
      if (rc == -1 && errno == EINTR) continue;
      BBDcd->LogProc = 0;
      if (WIFEXITED(status))
         BBDcd->Mlogrc = WEXITSTATUS(status);
      else
         BBDcd->Mlogrc = 102;
      if (BBDcd->Mlogrc == BBDcErrFork)
         sem_post(BBDcd->pMlogSem);
      }

   /* Was it the input process? */
   while (BBDcd->InpProc) {
      rc = waitpid(BBDcd->InpProc, &status, WNOHANG);
      if (rc == 0) break;
      if (rc == -1 && errno == EINTR) continue;
      BBDcd->InpProc = 0;
      if (WIFEXITED(status))
         BBDcd->Minprc = WEXITSTATUS(status);
      else
         BBDcd->Minprc = 102;
      if (BBDcd->Minprc == BBDcErrFork)
         sem_post(BBDcd->pMinpSem);
      }

   } /* End bbdcchldsig() */


/*=====================================================================*
*                              bbdcinit                                *
*=====================================================================*/

void bbdcinittest(int nlhs, mxArray *plhs[],
      int nrhs, const mxArray *prhs[]) {

   mxArray *pexsi;               /* Ptr to BBDCEXSI info, if any */
   struct BBDComData *BBDcd;     /* Common BBD data struct */
   struct sockaddr_in cnsserv;
   struct sigaction childchk;
   struct hostent *hp, *gethostbyname();
   char   *pvdefs;               /* Ptr to actual vardefs */
   char   *tchnm,*tshnm;         /* Temps for client, server IPs */
   mwSize lnm;                   /* Length of a name */
   mwSize lvdefs;                /* Length of vardefs */
   si32   port = BBDPortInit;    /* Port for CNS initiation */
   int    CNSin = 0;             /* CNS input file descriptor */
   int    log = 0;               /* CNS log file descriptor */
   int    minplog = 0;           /* minp process log descriptor */
   int    nvdefs = 0;            /* Number of items in vardefs */
   int    retver = 0;            /* Options argument */
   int    irhs;                  /* Index of next RHS arg */
   int    lchnm;                 /* Lengths of chnm, shnm */
   int    nxargs;                /* Number of bbdcminp args */
   enum rhargs jrhs;             /* Positional argument index */

#ifdef DBG_MINP
   char   dbgmsg[120];
#endif

/* Standard MATLAB check for proper number of arguments */

   if (nlhs != 1 || nrhs < 2 || nrhs > MxInitArgs)
      abexitm(BBDcErrInitArgs, "Wrong number args to bbdcinit");

/* Create the common data area and initialize linked lists */

   BBDcdA = plhs[0] = mxCreateNumericMatrix(
      sizeof(struct BBDComData), 1, mxUINT8_CLASS, mxREAL);
   mexMakeArrayPersistent(plhs[0]);
   BBDcd = (struct BBDComData *)mxGetData(plhs[0]);
   BBDcd->ppfeff = &BBDcd->pfeff;
   BBDcd->ppfsns = &BBDcd->pfsns;
   BBDcd->ppfttv = &BBDcd->pfttv;
   BBDcd->ppfetv = &BBDcd->pfetv;
   BBDcd->ppfstv = &BBDcd->pfstv;
   BBDcd->ppfval = &BBDcd->pfval;

/* Pick up arguments and establish defaults */

   tshnm = NULL;                 /* Default host */
   jrhs = jcnsf;
   /* We allow the vardefs struct to occur anywhere in the args */
   for (irhs=0; irhs<nrhs; ++irhs) {

      /* Check for and interpret struct argument */
      if (mxIsStruct(prhs[irhs])) {
         mxArray *pvval;         /* Value of variable */
         const char *pvnm;       /* Name of variable */
         mwSize ovdefs;          /* Offset to vdefs in ppvdefs */
         size_t lvname;          /* Length of variable name */
         size_t lvalue;          /* Length of value */
         int ivd;                /* vardef index */
         int nptrs;              /* Number ptrs in ppvdefs */
         nvdefs = mxGetNumberOfFields(prhs[irhs]);
         nptrs = nvdefs + (NBaseMinpArgs + 1);
         /* Add one ptr for execvp end mark */
         lvdefs = nptrs*sizeof(char *) + nvdefs *
            /* Add 2 chars/symbol for '=' and end mark */
            ALIGN_UP(MxLSymbol + MxLSValue + 2);
         BBDcd->ppvdefs = mxMalloc(lvdefs);
         pvdefs = (char *)(BBDcd->ppvdefs + nptrs);
         for (ivd=0; ivd<nvdefs; ++ivd) {
            pvnm = mxGetFieldNameByNumber(prhs[irhs], ivd);
            if ((lvname = strlen(pvnm)) > MxLSymbol)
               abexitm(BBDcErrVarNLong, ssprintf(NULL,
                  "Variable name %16s is too long", pvnm));
            pvval = mxGetFieldByNumber(prhs[irhs], 0, ivd);
            if (!mxIsChar(pvval))
               abexitm(BBDcErrValStr, ssprintf(NULL,
                  "Definition for %16s must be a string", pvnm));
            if ((lvalue = mxGetNumberOfElements(pvval)) > MxLSValue)
               abexitm(BBDcErrVarValue, ssprintf(NULL,
                  "Definition for %16s is too long", pvnm));
            BBDcd->ppvdefs[ivd+NBaseMinpArgs] = pvdefs;
            strcpy(pvdefs, pvnm); pvdefs += lvname;
            *pvdefs++ = '=';
            if (mxGetString(pvval, pvdefs, ++lvalue))
               abexit(BBDcErrVarValue);
            pvdefs += lvalue;
#ifdef DBG_VARDEF
   mexPrintf("Vardef %d name is %s, value is %s\n", ivd, pvnm,
      BBDcd->ppvdefs[ivd+NBaseMinpArgs]);
#endif
            } /* End loop over structure elements */
         /* Go to next argument without incrementing jrhs */
         continue;
         } /* End processing vardefs structure */

      switch (jrhs) {

      case jcnsf:          /* Deal with cnsfile argument */
         if (!mxIsChar(prhs[irhs]) ||
               (lnm = mxGetNumberOfElements(prhs[irhs])) == 0)
            abexitm(BBDcErrCtlArg, "Bad cnsfile to bbdcinit");
         else {
            char *pctrl = mxMalloc(lnm+1); /* (Terminates on failure) */
            if (mxGetString(prhs[irhs], pctrl, lnm+1))
               abexit(BBDcErrCtlArg);
            if ((CNSin = open(pctrl, O_RDONLY)) <= 0)
               abexitme(BBDcErrControl,
                  "Could not open CNS input file");
            mxFree(pctrl);
            }
         break;

      case jlogf:          /* Deal with the logfile argument */
         if (!mxIsChar(prhs[irhs]) ||
               (lnm = mxGetNumberOfElements(prhs[irhs])) == 0)
            abexitm(BBDcErrLogArg, "Bad logfile to bbdcinit");
         else {
            /* Be sure we have permission to write to the log file */
            char *plog = mxMalloc(lnm+1); /* (Terminates on failure) */
            if (mxGetString(prhs[irhs], plog, lnm+1))
               abexit(BBDcErrLogArg);
#ifdef _ISOC99_SOURCE
            if ((log = open(plog, O_WRONLY|O_CREAT|O_TRUNC,
               S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) < 0)
#else
            if ((log = open(plog, O_WRONLY|O_CREAT|O_TRUNC,
                  S_IREAD|S_IWRITE|S_IRGRP|S_IROTH)) < 0)
#endif
               abexitme(BBDcErrLogFile, "Could not open log file "
                  "for writing");
            mxFree(plog);
            }
         break;

      case jretv:          /* Deal with retver argument */
         if (mxGetNumberOfElements(prhs[irhs]) != 1)
            abexitm(BBDcErrRetVer,
               "retver arg to bbdcinit must be a scalar");
         if (mxIsDouble(prhs[irhs]))
            retver = (int)(*(double *)mxGetData(prhs[irhs]));
         else if (mxIsInt32(prhs[irhs]))
            retver = *(int *)mxGetData(prhs[irhs]);
         else
            abexitm(BBDcErrRetVer,
               "retver arg to bbdcinit is wrong type");
         break;

      case jhost:          /* Deal with host argument */
         if (!mxIsChar(prhs[irhs]))
            abexitm(BBDcErrHostName, "Bad host to bbdcinit");
         lnm = mxGetNumberOfElements(prhs[irhs]);
         if (lnm > 0) {
            tshnm = mxMalloc(lnm+1);
            if (mxGetString(prhs[irhs], tshnm, lnm+1))
               abexit(BBDcErrHostName);
            }
         break;

      case jport: {        /* Deal with port number */
         si32 tport;
         if (mxGetNumberOfElements(prhs[irhs]) != 1)
            abexitm(BBDcErrPortNum,
               "port arg to bbdcinit must be a scalar");
         if (mxIsDouble(prhs[irhs]))
            tport = (si32)(*(double *)mxGetData(prhs[irhs]));
         else if (mxIsInt32(prhs[irhs]))
            tport = *(si32 *)mxGetData(prhs[irhs]);
         else
            abexitm(BBDcErrPortNum,
               "port arg to bbdcinit is wrong type");
         if (tport > 0) port = tport;
         break;
         } /* End port local scope */

         } /* End argument number switch */
      jrhs += 1;
      } /* End loop over arguments */

/* Deal with client and server names */

   if (tshnm) {
      char *semic = strchr(tshnm,';');
      if (semic) {
         tchnm = semic + 1;
         lchnm = strnlen(tchnm, MAX_FQDN_LENGTH);
         lnm   = semic - tshnm;
         BBDcd->chnm = mxMalloc(lchnm + lnm + 2);
         memcpy(BBDcd->chnm, tchnm, lchnm);
         BBDcd->chnm[lchnm] = '\0';
         BBDcd->shnm = BBDcd->chnm + lchnm + 1;
         }
      else {
         BBDcd->chnm = BBDcd->shnm = mxMalloc(lnm+1);
         }
      memcpy(BBDcd->shnm, tshnm, lnm);
      BBDcd->shnm[lnm] = '\0';
      mxFree(tshnm);
      }
   else {
      tshnm = LocalHostIP;
      lnm = strlen(tshnm);
      BBDcd->chnm = BBDcd->shnm = mxMalloc(lnm+1);
      strncpy0(BBDcd->chnm, tshnm, lnm);
      }
   mexMakeMemoryPersistent(BBDcd->chnm);

   BBDcd->Vclients = retver & ~NOMINPLOG;

/* Deal with BBDCEXSI.  Note that because there could be some delay
*  before the forked subprocess accesses the exsi data, this memory
*  is made persistent here and is destroyed in bbdcquit.  */

   pexsi = mexGetVariable("global", "BBDCEXSI");
   if (pexsi) {
      size_t lexsi;
      if (!mxIsChar(pexsi))
         abexitm(BBDcErrExsi, "bbdcexsi info is not a string");
      lexsi = mxGetNumberOfElements(pexsi);
      if (lexsi > 0) {
         BBDcd->exsi = mxMalloc(lexsi+1);
         mexMakeMemoryPersistent(BBDcd->exsi);
         if (mxGetString(pexsi, BBDcd->exsi, lexsi+1))
            abexitm(BBDcErrExsi, "Unable to copy bbdcexsi info");
         mxDestroyArray(pexsi);
         }
      }

/* Set up action for child process death */

   childchk.sa_handler = bbdcchldsig;
   sigemptyset(&childchk.sa_mask);
   childchk.sa_flags = SA_NOCLDSTOP;
   if (sigaction(SIGCHLD, &childchk, NULL) < 0)
      abexitme(BBDcErrFork, "Could not install SIGCHLD handler");

/* Tell system to ignore SIGPIPE signals.  This is so socket
*  reads will detect a dead server and give a meaningful error
*  message.  This setting should, according to some documentation,
*  (1) be unnecessary (not in practice), and (2) be inherited by
*  our child processes.  See also Implementation Note above.  */

   signal(SIGPIPE, SIG_IGN);

/* Create semaphores that will be used by bbdcchk to determine that
*  the two child processes are OK.  Checking BBDcd->Minprc is not
*  good enough if main process gets to bbdcchk before child can
*  signal error exit.  */

   if ((BBDcd->pMlogSem = sem_open(MlogSemNm, O_CREAT,
         URW_Mode, 0)) == SEM_FAILED)
      abexitme(BBDcErrSema, "Could not open " MlogSemNm);
   if ((BBDcd->pMinpSem = sem_open(MinpSemNm, O_CREAT,
         URW_Mode, 0)) == SEM_FAILED)
      abexitme(BBDcErrSema, "Could not open " MinpSemNm);

/* Indicate that bbdcminp process has not yet finished, then
*  tell MATLAB to call bbdcqex() whenever it exits.  */

   BBDcd->Mlogrc = BBDcd->Minprc = -1;
   mexAtExit(bbdcqex);

/* Create a socket and try to contact CNS.  We'll not use rfallo,
*  etc. here because copying to log runs in a child process and
*  uses select().  */

#ifdef DBG_MINP
   mexPrintf("About to create Cns call socket\n");
#endif

   if ((BBDcd->Cnssock = socket(PF_INET, SOCK_STREAM, 0)) < 0)
      abexitme(BBDcErrSocket, "Could not create a socket to "
         "invoke CNS");

   cnsserv.sin_family = AF_INET;
   cnsserv.sin_port = htons(port);
   if (!(hp = gethostbyname(BBDcd->shnm)))
      abexitm(BBDcErrConnect, ssprintf(NULL, "Errno %4d looking "
         "up IP addr for host %64s", h_errno, BBDcd->shnm));
   memcpy((char *)&cnsserv.sin_addr, (char *)hp->h_addr,
      hp->h_length);

#ifdef DBG_MINP
   mexPrintf("Trying to connect to Cns socket %d\n", BBDcd->Cnssock);
#endif

   if (connect(BBDcd->Cnssock, (struct sockaddr *)&cnsserv,
         sizeof(cnsserv)) < 0)
      abexitme(BBDcErrConnect, "Could not open a connection "
         "to CNS server");

/* Apparently, we got a connection, so fork a process to
*  maintain the log.  */

   if ((BBDcd->LogProc = fork()) < 0)
      abexitme(BBDcErrFork, "Could not fork a process to "
         "maintain the CNS log");
   if (!BBDcd->LogProc) {
      char *logargv[4];
      char asck[LMxClSPAA],alog[LMxClSPAA];
#ifdef OSX
      char *ehome,*logpath;
      char *logname = "/bin/bbdcmlog";
      ehome = getenv("HOME");
      if (!ehome) exit(BBDcErrNoHome);
      logpath = malloc(strlen(ehome) + strlen(logname) + 1);
      strcpy(logpath, ehome);
      strcat(logpath, logname);
      logargv[0] = logpath;
#else
      logargv[0] = "bbdcmlog";
#endif
      logargv[1] = ssprintf(asck, qMxClSPAfmt "d", BBDcd->Cnssock);
      logargv[2] = ssprintf(alog, qMxClSPAfmt "d", log);
      logargv[3] = NULL;
      execvp(logargv[0], logargv);
      exit(BBDcErrFork);      /* JIC */
      }

/* Open a second socket on the next higher-numbered port and listen
*  for CNS to send confirmation of the configuration.  Note that
*  this socket uses the ROCKS library for buffering and the socket
*  is left pending until the BBD calls bbdcchk, thus allowing the
*  BBD to continue setup in parallel with CNS setup until the two
*  processes finally must liaison.  */

   BBDcd->DataPort = port + 1;
#ifdef DBG_MINP
   mexPrintf("About to call rfallo for data port\n");
#endif
   BBDcd->ndrecv = rfallo(NULL, READ, TEXT, LISTENER, TOP,
      NO_LOOKAHEAD, NO_REWIND, RELEASE_BUFF, IGNORE, IGNORE,
      BBDcd->DataPort, ABORT);
#ifdef DBG_MINP
   mexPrintf("Returned from rfallo for data port\n");
   retver &= ~NOMINPLOG;   /* Force log on if debugging */
#endif

/* Open a file for bbdcminp logging (this can be turned off if
*  necessary by setting the NOMINPLOG bit in the retver argument). */
   if (!(retver & NOMINPLOG)) {
#ifdef _ISOC99_SOURCE
      if ((minplog = open(MINP_LOG_FILE, O_WRONLY|O_CREAT|O_TRUNC,
            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) < 0)
#else
      if ((minplog = open(plog, O_WRONLY|O_CREAT|O_TRUNC,
            S_IREAD|S_IWRITE|S_IRGRP|S_IROTH)) < 0)
#endif
         abexitme(BBDcErrLogFile, "Could not open bbdcminp log file "
            "for writing");

#ifdef DBG_MINP
      strcpy(dbgmsg, "Minp log file opened by bbdcinit OK\n");
      mexPrintf(dbgmsg);
#endif
      }

/* Now it is safe to fork another process to send the input file
*  to CNS.  This allows this main process to go ahead with its
*  business while CNS sets up (possibly in a different computer).
*  This also allows for possible future development in which the
*  client can actually interrupt CNS, send CHANGE cards, and restart.
*/

   /* If there were no vardefs, now must allocate for minp args */
   if (!nvdefs) {
      lvdefs = (NBaseMinpArgs+1)*sizeof(char *);
      BBDcd->ppvdefs = mxMalloc(lvdefs); }
   mexMakeMemoryPersistent(BBDcd->ppvdefs);
#ifdef DBG_MINP
      strcpy(dbgmsg, "bbdcinit at Minp fork OK\n");
      mexPrintf(dbgmsg);
#endif
   if ((BBDcd->InpProc = fork()) < 0)
      abexitme(BBDcErrFork, "Could not fork a process to "
         "communicate neural data with CNS");
   if (!BBDcd->InpProc) {
      /* Now I am in the new memory space, must copy args here */
      char asock[2*LMxClSPAA],ainp[LMxClSPAA];
      char avcl[LMxClSPAA],aport[LMxClSPAA];
#ifdef OSX
      char *ehome,*inppath;
      char *inpname = "/bin/bbdcminp";
#endif
      char **ppargs;
      ppargs = (char **)malloc(lvdefs);
      /* Copy any vardefs */
      if (nvdefs)
         memcpy(ppargs+NBaseMinpArgs, BBDcd->ppvdefs+NBaseMinpArgs,
            lvdefs - NBaseMinpArgs*sizeof(char *));
#ifdef OSX
      ehome = getenv("HOME");
      if (!ehome) exit(BBDcErrNoHome);
      inppath = malloc(strlen(ehome) + strlen(inpname) + 1);
      strcpy(inppath, ehome);
      strcat(inppath, inpname);
      ppargs[mnpnm] = inppath;
#else
      ppargs[mnpnm] = "bbdcminp";
#endif
      if (minplog > 0)
         ssprintf(asock, qMxClSPAfmt "d " qMxClSPAfmt "d",
            BBDcd->Cnssock, minplog);
      else
         ssprintf(asock, qMxClSPAfmt "d", BBDcd->Cnssock);
      ppargs[mnpsock] = asock;
      ppargs[mnpinfd] = ssprintf(ainp,  qMxClSPAfmt "d", CNSin);
      ppargs[mnpchnm] = BBDcd->chnm;
      ppargs[mnpvcli] =
         ssprintf(avcl,  qMxClSPAfmt "d", BBDcd->Vclients);
      ppargs[mnpport] =
         ssprintf(aport, qMxClSPAfmt "d", BBDcd->DataPort);
      /* If no exsi info, insert a dummy */
      ppargs[mnpxtra] = pexsi ? BBDcd->exsi : NoEXSI;
      ppargs[mnpvard+nvdefs] = (char *)NULL;
#ifdef DBG_MINP
      if (minplog > 0) {
         strcpy(dbgmsg, "Running in Minp space, "
            "just before execvp OK\n");
         write(minplog, dbgmsg, strlen(dbgmsg));
         fsync(minplog);
         }
#endif
      execvp(ppargs[0], ppargs);
      exit(BBDcErrFork);      /* JIC */
      }

/* Return so the BBD can continue setting up.  When it is ready
*  to go, it must call bbdcchk() to match configurations with
*  CNS and prepare to exchange "neuronal" data.  */

#ifdef DBG_MINP
   mexPrintf("Returned from bbdcminp fork OK\n");
   mexPrintf("At exit from bbdcinit, LogProc = %d, InpProc = %d, "
      "Minprc = %d, Mlogrc = %d\n", (int)BBDcd->LogProc,
      (int)BBDcd->InpProc, BBDcd->Minprc, BBDcd->Mlogrc);
#endif   /*** ENDDEBUG ***/

   } /* End bbdcinit() */

/*=====================================================================*
*                          bbdcinit wrapper                            *
*=====================================================================*/

void mexFunction(int nlhs, mxArray *plhs[],
      int nrhs, const mxArray *prhs[]) {

   bbdcinittest(nlhs, plhs, nrhs, prhs);

   }

