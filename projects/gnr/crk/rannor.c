/* (c) Copyright 1989-2013, The Rockefeller University *11115* */
/* $Id: rannor.c 61 2017-01-16 19:26:44Z  $ */
/***********************************************************************
*                  ROCKS Library - C Implementation                    *
*                               RANNOR                                 *
*                                                                      *
*     RANNOR - Generate normally distributed pseudo-random floating    *
*              point numbers                                           *
*                                                                      *
************************************************************************
*  V1A, 02/28/89, G. N. REEKE                                          *
*  Rev, 04/19/89, GNR - Incorporate rkarith.h                          *
*  ==>, 07/01/02, GNR - Last date before committing to svn repository  *
*  V1C, 12/22/09, GNR - Modify for 64-bit compilations, calc w/o call  *
*                       to udev                                        *
*  Rev, 10/25/13, GNR - Get rid of 'L' constants                       *
***********************************************************************/

/*
      Usage: void rannor(float *r, int n, si32 *seed,
         float mean, float sigma)

      Arguments:
         r     = floating point array to contain n result values.
         n     = number of values to be generated.
         seed  = any integer from 1 to 2**31-1 (it is replaced
                  on return by a new value for the next call).
         mean  = mean value of the normal distribution.
         sigma = standard deviation of the normal distribution.

      Algorithm:  Uniformly distributed pseudo-random integers
         are generated by ir[i] = ir[i-1]*(7**5) MODULO (2**31-1).
         The first eight bits of each are used to select from a
         look-up table an interval of width 0.125 in the range
         0.0-3.0 with appropriate frequency.  The remaining bits
         specify the location within the chosen intervala and
         the sign.  The resulting value is multiplied by 'sigma'
         and finally 'mean' is added.  The result is a piecewise
         rectangular approximation to the true Gaussian distribu-
         tion, good enough for most purposes.  See Knuth, Vol. 2.

      Notes:  This program was modified (V1C) to compute the uni-
         form random numbers in line, rather than using dm64nr().
         Since rannor may be very heavily used, it may be desire-
         able to implement the whole thing in Assembler.

      Limitation:  Values more than 3 * sigma from the mean are
         never generated.

      Errors:  The application is terminated with error code 071
         if n < 1.
*/

#include <stddef.h>
#include <math.h>
#include "sysdef.h"
#include "rkarith.h"

void rannor(float *nr, int n, si32 *seed, float mean, float sigma) {

   /* Table of probabilities for normal distribution generator */
   extern const unsigned char normtab[256];

   float fnr;                    /* Result */
   ui32 smlo = (ui32)(*seed);    /* Seed and low-order product */
   si32 frac;                    /* Fraction for linear interp */
   int i;                        /* Counter */

   if (n < 1) abexit(71);        /* Error trap */

   for (i=0; i<n; i++) {         /* Calculate n values */

/* Get a uniform random number--avoid a call to udev() */

#ifdef HAS_I64                   /* --- 64-bit version --- */

#if LSIZE == 8
#define m 16807L                 /* The magic multiplier */
#define w31 0x7fffffffL          /* Base, 2**31 - 1 */
#else
#define m 16807LL
#define w31 0x7fffffffLL
#endif
      /* Calculate the product and remainder with 64-bit arithmetic */
      ui64 sm = (ui64)smlo * m;
      sm = (sm & w31) + (sm >> 31);
      sm = (sm & w31) + (sm >> 31);
      smlo = (ui32)sm;
#else                            /* --- 32-bit version --- */
#define m 16807L
      /* Form the product in low 16 and high 31 bit pieces */
      ui32 s0m = (smlo & 0xffffL) * m;
      ui32 s1m = (smlo >> 16) * m + (s0m >> 16);
      /* Form remainder modulo (2**31-1) using Knuth trick */
      smlo = (s0m & 0xffffL) + ((s1m & 0x7fffL) << 16) + (s1m >> 15);
      /* Final adjustment--if the result exceeds (2**31-1), subtract
      *  (2**31-1) one more time.  This boils down to: if the sign
      *  bit is set, clear the sign and add one.  */
      smlo = (smlo + (smlo >> 31)) & 0x7fffffffL;
#endif

/* Use the left 8 bits as an index to pick up a rectangle.
*  Combine 7 bits from rectangle w/22 from fraction. */

      frac = (si32)(smlo & 0x003fffff) |
            ((si32)normtab[smlo >> 23] << 22);
      fnr = (float)frac/((float)(1<<25));
      if (smlo & (ui32)0x00400000) fnr = -fnr;
      *nr++ = mean + sigma*fnr;
      } /* End loop over n values */

   *seed = (si32)smlo;           /* Store final seed back to caller */

   } /* End rannor subroutine */

