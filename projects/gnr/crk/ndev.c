/* (c) Copyright 1999-2013, The Rockefeller University *11115* */
/* $Id: ndev.c 61 2017-01-16 19:26:44Z  $ */
/***********************************************************************
*                  ROCKS Library - C Implementation                    *
*                                ndev                                  *
*                                                                      *
*  This function generates a single normally distributed pseudorandom  *
*  number drwn from a distribution with given mean and sigma.          *
*                                                                      *
*  Synopsis:  si32 ndev(si32 *seed, si32 cmn [Sa], si32 csg [Sa+4])    *
*                                                                      *
*  Algorithm:  Uniformly distributed pseudo-random integers are        *
*  generated by ir = seed*(7**5) MODULO (2**31-1).  The special        *
*  form of the divisor permits the MODULO operation to be carried      *
*  out without actual division.  The first eight bits of ir are        *
*  used to select from a look-up table an interval of width 0.125      *
*  in the range 0.0-3.0 with appropriate frequency.  The remaining     *
*  bits specify the location within the chosen interval and the        *
*  sign.  The resulting value is multiplied by 'sigma' and finally     *
*  'mean' is added.  The result is a piecewise rectangular approxi-    *
*  mation to the true Gaussian distribution, good enough for most      *
*  purposes.  See Knuth, Vol. 2.                                       *
*                                                                      *
*  Scaling:  cmn can have any desired binary scale (number of fraction *
*  bits), [Sa].  csg must have four more fraction bits than cmn.  The  *
*  result has the same scale as cmn.                                   *
*                                                                      *
*  This routine is implemented in Assembly language on most machines   *
*  because the lack of provision for 64-bit multiplication and 32-bit  *
*  arithmetic carry in the C language makes implementation clumsy and  *
*  execution slow in C.  The present C code is intended to provide a   *
*  working version to get started on a new port.  Exact compatibility  *
*  with the traditional ndev routine is the goal here, not speed. The  *
*  code to calculate the initial uniformly distributed random number   *
*  is copied directly from udev.c.  Examination of the code emitted by *
*  the C compiler may provide a useful template for a new Assembler    *
*  implementation.                                                     *
*                                                                      *
************************************************************************
*  Initial version, 06/12/99, G. N. Reeke                              *
*  ==>, 07/01/02, GNR - Last date before committing to svn repository  *
*  Rev, 11/15/09, GNR - Modify for 64-bit compilation                  *
*  Rev, 10/24/13, GNR - Use jm64nh for 64-bit to avoid signed '>>'     *
***********************************************************************/

#include <stddef.h>
#include <math.h>
#include "sysdef.h"
#include "rkarith.h"

si32 ndev(si32 *seed, si32 cmn, si32 csg) {

   /* Table of probabilities for normal distribution generator */
   extern const unsigned char normtab[256];

   ui32 smlo;
   si32 frac;

/* Get a uniform random number and update the seed
*  in order to avoid a call to udev() */

#ifdef HAS_I64                   /* --- 64-bit version --- */

#if LSIZE == 8
#define m 16807L                 /* The magic multiplier */
#define w31 0x7fffffffL          /* Base, 2**31 - 1 */
#else
#define m 16807LL
#define w31 0x7fffffffLL
#endif
   /* Calculate the product and remainder with 64-bit arithmetic */
   ui64 sm = (ui64)(*seed) * m;
   sm = (sm & w31) + (sm >> 31);
   sm = (sm & w31) + (sm >> 31); /* Do it again */
   smlo = (ui32)sm;
#else                            /* --- 32-bit version --- */
#define m 16807L
   /* Form the product in low 16 and high 31 bit pieces */
   ui32 smhi, s0m = ((ui32)(*seed) & 0xffffL) * m;
   smlo = s0m & 0xffffL;
   smhi = ((ui32)(*seed)>>16)*m + (s0m>>16);
   /* Form remainder modulo (2**31-1) using Knuth trick */
   smlo += ((smhi & 0x7fffL) << 16) + (smhi >> 15);
   /* Final adjustment--if the result exceeds (2**31-1), subtract
   *  (2**31-1) one more time.  This boils down to: if the sign
   *  bit is set, clear the sign and add one.  */
   smlo = (smlo + (smlo >> 31)) & 0x7fffffffL;
#endif

   *seed = (si32)smlo;           /* Save updated seed */

/* Use the left 8 bits as an index to pick up a rectangle.
*  Combine 7 bits from rectangle, 22 from fraction, 3 zeros. */

   frac = ((si32)(smlo & 0x003fffff) << 3) |
          ((si32)normtab[smlo >> 23] << 25);

/* Multiply by standard deviation (S28 + (Sa+4) - 32 = Sa) */

   frac = jm64nh(csg, frac);

/* Negate combined result if bit 22 was set */

   if (smlo & 0x00400000) frac = -frac;

/* Add mean (S24) */

   return (frac + cmn);

   } /* End ndev() */
