/* (c) Copyright 1997-2016, The Rockefeller University *11115* */
/* $Id: ssprintf.c 61 2017-01-16 19:26:44Z  $ */
/***********************************************************************
*                  ROCKS Library - C Implementation                    *
*                              SSPRINTF                                *
*                                                                      *
*  Subroutine ssprintf ("subset sprintf") provides a small subset of   *
*  the facilities available in the standard C library function sprintf *
*  in a completely self-contained unit.  It is intended mainly for use *
*  in generating message texts on parallel computer nodes where other  *
*  formatting facilities may require too much memory or may be         *
*  unavailable altogether.                                             *
*                                                                      *
*  Usage:  char *ssprintf(char *string, char *format, ...)             *
*                                                                      *
*  Prototyped in:  sysdef.h                                            *
*                                                                      *
*  ARGUMENTS:                                                          *
*     string   is a character array large enough to hold the output    *
*              generated by ssprintf(), including a null terminator.   *
*              If a NULL pointer is passed, ssprintf() will use its    *
*              own internal buffer, of size LNSIZE.  The user is       *
*              responsible to code the format string in such a way     *
*              that the size of 'string' is not exceeded.              *
*                                                                      *
*     format   is a message text possibly containing format control    *
*              elements.  The format string is copied to the output    *
*              except as follows:                                      *
*        (1) Each occurence of '%<n>s' results in copying up to a      *
*              maximum of <n> characters from another string, taken    *
*              from the next ssprintf argument, into the output.       *
*              If the argument is a NULL pointer, nothing is copied    *
*              and no error occurs.                                    *
*        (2) Each occurence of '%<n>d' results in converting an        *
*              integer, taken from the next ssprintf argument, into    *
*              its decimal representation as a character string and    *
*              copying up to a maximum of <n> characters from this     *
*              string into the output.  If the code is '%<n>ld', the   *
*              argument is a long rather than an int.  If the code is  *
*              '%<n>jd', the argument is an si32 rather than an int.   *
*              If the code is '%<n>zd', the argument is a size_t.      *
*              If the code contains 'ed' rather than 'd', the length   *
*              of the output is exactly <n> characters and any excess  *
*              digits are discarded.                                   *
*        (3) Each occurence of '%<n>X' or '%<n>x' results in convert-  *
*              ing an integer, taken from the next ssprintf argument,  *
*              into its upper-or lower-case hexadecimal representa-    *
*              tion, respectively, and copying a maximum of <n>        *
*              characters from this string into the output.  If the    *
*              code is '%<n>lx', the argument is a long rather than    *
*              an int.  If the code is '%<n>jx', the argument is an    *
*              int32 rather than an int.  If the code contains 'ex'    *
*              or 'eX' rather than 'x' or 'X', the length of the out-  *
*              put is exactly <n> characters and any excess digits     *
*              are discarded.                                          *
*        (4) Each occurrence of '%p' or '%P' results in converting a   *
*              pointer, taken from the next ssprintf argument, into    *
*              a hexadecimal representation of length appropriate to   *
*              the processor and copying this string into the output   *
*              (useful where pointers and ints are different lengths). *
*        (5) Each occurence of '%<n>m' results in converting <n>       *
*              memory bytes from storage pointed to by the next        *
*              ssprintf argument to hexadecimal and copying the        *
*              resulting 2n characters to the output.                  *
*                                                                      *
*              In all of the above cases, the length specification <n> *
*              can be an asterisk (*), in which case the length is     *
*              taken from the next argument, which must be an integer. *
*              No escape characters are recognized.  If an external    *
*              buffer is used, then the string length specifications   *
*              '<n>' are required.  This is necessary to assure that   *
*              the output cannot exceed the length of the 'string'     *
*              argument.                                               *
*                                                                      *
*  RETURNS:    A pointer to the result character string.  If a NULL    *
*              string argument was used, the result is valid only      *
*              until the next call to ssprintf.                        *
*                                                                      *
*  ERRORS:     ssprintf terminates with abexit code 58 if a length     *
*              specification is missing (except with p or P), and      *
*              with abexit code 59 if the format code is other than s, *
*              d, p, P, x, X, or m.  If the length of the internal     *
*              buffer is exceeded the program simply returns, allowing *
*              partial output of error msgs.                           *
*                                                                      *
*  NOTE:       The use of the count field is different than it is in   *
*              standard sprintf.  Here it is the maximum field width,  *
*              there it is the minimum.  Code 'ed' can be used to      *
*              force longer than the minimum width to make aligned     *
*              columns.                                                *
*                                                                      *
*  NOTE:       When processing an unknown format string (e.g. in an    *
*              implementation of fatale() or abexitm(), use the in-    *
*              ternal buffer to be sure buffer overflow is detected.   *
*                                                                      *
*  NOTE:       There is no provision for formatting floating point     *
*              numbers nor 64-bit integers in a 32-bit environment.    *
*              At present, 'jd' is same as 'd' and 'jx' is same as     *
*              'x', but this prepares us for the case that they might  *
*              be different (e.g. 16 bit int).                         *
*                                                                      *
************************************************************************
*  V1A, 11/09/97, GNR - New routine                                    *
*  V2A, 03/28/98, GNR - Add length checking with internal buffer       *
*  V2B, 07/09/98, GNR - Fix bug that swallowed adjacent '%' codes      *
*  V2C, 05/31/00, GNR - Add %m code, useful for debug memory dumps     *
*  Rev, 09/19/08, GNR - Add ld, lx, lX codes for when long != int      *
*  ==>, 09/19/08, GNR - Last date before committing to svn repository  *
*  Rev, 07/22/11, GNR - Add jd, jx codes to force 32-bit arguments     *
*  Rev, 10/04/15, GNR - Add 'ed' code                                  *
*  Rev, 04/23/16, GNR - Add 'zd' code                                  *
***********************************************************************/

#include <ctype.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include "sysdef.h"

char *ssprintf(char *string, char *format, ...) {

   va_list args;              /* Argument list */
   char *pb0,*pb,*pbe;        /* Ptrs to output buffer */
   char *pd;                  /* Ptr to output data string */
/* The point of this #if is that machines that don't have 8-byte
*  longs are likely also not to have the ldiv function, so we
*  just use div for both sizes */
#if LSIZE != ISIZE
#define Divqrm ldiv
   ldiv_t qrm;                 /* Quotient and remainder */
#else
#define Divqrm div
   div_t  qrm;
#endif
   long lval,aval;            /* Long argument, abs(lval) */
   unsigned long xval;        /* Hexadecimal argument */
   int gotl;                  /* Argument length code */
#define LDFLT  0                 /* Default integer */
#define LSZ32  1                 /* Int32 'j' code  */
#define LLONG  2                 /* Long  'l' code  */
#define LSIZET 4                 /* size_t 'z' code */
#define LEXACT 8                 /* Got 'ed' code   */
   int width;                 /* Maximum field width */
   char code;                 /* Next format code */
   char digits[LONG_SIZE+2];  /* Storage for decimal conversion */
   static char sspb[LNSIZE];  /* Permanent off-stack msg space */

   va_start(args, format);

/* If user did not provide a buffer, use the internal one.
*  Set up overflow check for internal buffer only.  */

   if (string)
      pb = pb0 = string, pbe = NULL;
   else
      pb = pb0 = sspb, pbe = sspb + sizeof(sspb);

/* Scan through the format.  Transfer characters to the output
*  until the end of the format string or a '%' is encountered.
*/

   while ((pbe == NULL || pb < pbe) && *format) {
      if (*format == '%') {
         gotl = LDFLT;
         /* Interpret the width field */
         if (format[1] == '*') {    /* Get width from an arg */
            width = va_arg(args, int);
            format += 2;
            code = *format;
            }
         else {
            width = 0;
            for (;;) {              /* Read width */
               code = *(++format);
               if (!isdigit(code)) break;
               width = (width<<3) + width + width + (code - '0');
               }
            }
         if (code == 'p' || code == 'P') {
            if (width < 2*sizeof(void *)) width = 2*sizeof(void *); }
         else if (code == 'm')
            width <<= 1;
         if (pbe) {
            int wrem = pbe - pb;
            if (wrem <= 0) { pb[-1] = '\0'; break; }
            if (width == 0 || width > wrem) width = wrem;
            }
         else if (!width)
            abexit(58);
         if (code == 'j') { gotl = LSZ32; code = *(++format); }
         else if (code == 'l') { gotl = LLONG; code = *(++format); }
         else if (code == 'z') { gotl = LSIZET; code = *(++format); }
         if (code == 'e') { gotl |= LEXACT; code = *(++format); }
         ++format;
         switch (code) {
         case 's':                  /* Include string */
            if (gotl) abexit(59);
            if (!(pd = va_arg(args, char *)))   /* Assgn intended */
               break;
            while (width-- && *pd) *pb++ = *pd++;
            break;
         case 'd':                  /* Include decimal integer */
#if LSIZE != ISIZE
            if (gotl & LLONG)
               lval = va_arg(args, long);
            else if (gotl & LSIZET) {
               size_t zval = va_arg(args, size_t);
               lval = (long)zval; }
            else {
               int ival = va_arg(args, int);
               lval = (long)ival; }
#else
            lval = va_arg(args, long);
#endif
            pd = digits;
            aval = labs(lval);
            do {
               qrm = Divqrm(aval, 10);
               *pd++ = (char)qrm.rem + '0'; }
            while (aval = qrm.quot);   /* Assignment intended */
            if (lval < 0) *pd++ = '-';
            if (gotl & LEXACT) {
               int nbl = width - (pd - digits);
               while (nbl-- > 0) *pb++ = ' ';
               }
            while (width-- && pd > digits) *pb++ = *(--pd);
            break;
         case 'p':                  /* Include pointer */
         case 'P':
            if (gotl) abexit(59);
            xval = (unsigned long)va_arg(args, void *);
            code -= (10 + 'p' - 'a');
            goto hexcon;
         case 'x':                  /* Include hexadecimal integer */
         case 'X':
#if LSIZE == ISIZE
            xval = (unsigned long)va_arg(args, unsigned long);
#else
            if (gotl & LLONG)
               xval = (unsigned long)va_arg(args, unsigned long);
            else if (gotl & LSIZET) {
               size_t zval = va_arg(args, size_t);
               xval = (unsigned long)zval; }
            else {
               unsigned int ival = va_arg(args, unsigned int);
               xval = (unsigned long)ival; }
#endif
            code -= (10 + 'x' - 'a');
hexcon:     pd = digits;
            do {
               int ival = (int)(xval & 15);
               *pd++ = (ival < 10) ? (ival + '0') : (ival + code);
               } while (xval >>= 4);   /* Assignment intended */
            if (gotl & LEXACT) {
               int nbl = width - (pd - digits);
               while (nbl-- > 0) *pb++ = ' ';
               }
            while (width-- && pd > digits) *pb++ = *(--pd);
            break;
         case 'm':                  /* Include memory data */
            if (gotl) abexit(59);
            if (!(pd = va_arg(args, char *)))   /* Assgn intended */
               break;
            while (width > 0) {
               int ival = (unsigned char)*pd >> 4;
               *pb++ = (ival < 10) ? (ival + '0') : (ival + ('a'-10));
               if (width <= 1) break;
               ival = *pd++ & 15;
               *pb++ = (ival < 10) ? (ival + '0') : (ival + ('a'-10));
               width -= 2;
               }
            break;
         default:                   /* Unrecognized format code */
            abexit(59);
            } /* End code switch */
         } /* End processing '%' format */
      else {                        /* Move format to output */
         *pb++ = *format++;
         }
      } /* End while */

   *pb = '\0';
   va_end(args);                    /* Clean up argument list */
   return pb0;

   } /* End ssprintf() */
