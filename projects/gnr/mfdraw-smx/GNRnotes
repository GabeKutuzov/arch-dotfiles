[Revised, 12/09/07]
                   Guidelines for mfdraw development

Proposed changes are listed in order of decreasing importance.  Items
that should not change are not listed.  In particular, navigation in
socket movie mode remains the same except for implementation of the
functions described for the new buttons in item (6).  That is, the
user can move around among the frames currently in memory while
mfdraw continues to request and store new frames from the running
application.  However, when the available frame memory is full,
mfdraw will delete frames and acquire new frames only when the
current frame being viewed is at or beyond halfway through the
set of frames currently in memory.  The user can move or resize
the main viewing window, change background color, and zoom the
image while navigating behind the latest frame, but not when new
frames are being displayed as soon as received ("true movie mode"),
as then confusion can arise as to which frame is intended to be
changed.  The user can use the new Stop button described in item
(6) to freeze the movie-mode display on the current frame in order
to perform these functions.

Implementation suggestions are in a separate list following the
feature descriptions.

    (1) The magnification slider has to be made usable.
[Already solved with new "vector" widget.]  It is not necessary to
display a numeric value for the zoom factor, but if one is shown, it
should be the amount by which the scale of the image has been
multiplied relative to a scale of 1.0, considered as the size that
just allows the frame to fit in the current window.  This must take
into account changes made with the zoom widget or the arrow keys,
but not window resizes.
   (2) There will be a user-editable preferences file.  This file
will be called ".mfdrawrc".  When mfdraw starts up in metafile mode
with the file name on the command line, it will look for this file
first in the directory where the current metafile being viewed was
found, then in the home directory of the current user.  In other
modes, the first of these is not applicable, and the second refers to
the home directory of the user under whose userid the program is being
run.  In the event that neither preferences file is found, the program
will use compile-time defaults for all preferences.
   Items for inclusion in the preferences file, but not limited
to these, are:  Startup location of main window, background color,
minimum frame viewing time for fast-forward and fast-reverse buttons,
default X display, default index size, maximum number of frames to
store in memory (temporary), maximum memory to be devoted to storing
frames in memory (permanent).
   If the startup size is not given in the preferences file, the
existing defaults are excellent and should continue to be used.
(This option ignored if not supported by the window system in use.)
   I would like to be able to specify startup location by one of
the following options or similar, or with explicit x,y coordinates.:
ULHC, URHC, LLHC, LRHC -- Upper left-hand corner, etc.,
Center, Center Left, Center Right, Center Top, Center Bottom.
(This option ignored if not supported by the window system in use.)
   (3) There needs to be a minimum display time for the fast
forward and fast reverse buttons, rather than just drawing as
fast as possible as mfdraw does when in movie mode.  This time
can be read from the preferences file and overridden while running
by an item on the "File->Settings" menu.  The minimum frame viewing
time does not apply in movie mode.
   (4) The Home and Background buttons can be made into little
squares like the motion buttons and the titles replaced with icons,
for example, a cross inside a square for "Fit" and a square that is
black on one half and clear on the other half, perhaps divided
diagonally, for "Bkgrnd".
   (5)  I would like the "Home" button, better thought of as a "Fit"
button, to adjust the magnification and positioning of the frame to
just fit in the current window.  It probably would make sense also
to reset the scale origin to the original origin.
   (6) I would like to have seven navigation buttons as follows:
|<	Jump immediately to the earliest available frame (always
        frame 1 if viewing a metafile when (10) implemented).
<<      Step backwards through frames continually until Pause button
        or other button (item 6b) is clicked or first available frame
        is reached.  Speed as in items (3) and (6a).
<       Step back one frame.
||      Pause ongoing fast-forward or fast-reverse sequence.
        Continue when pressed again.
>       Step forward one frame.
>>      Step forwards through frames continually until Pause button
        or other button (item 6b) is clicked or last available frame
        is reached.  Speed as in items (3) and (6a).
>|      Jump immediately to the latest available frame (always
        the last frame in the file if viewing a metafile when (10)
        implemented).
These buttons work as stated in still mode or metafile mode.
None of them causes entry into movie mode.  Any of them, if
clicked in movie mode, causes updating of the display with new
images to stop while new frames continue to be acquired from
the application until the in-frame memory limitation is reached.
The stated action (reverse buttons) or no action (Pause or
forward buttons) then occurs.
   (6a) [Modification of item 6].  When in fast-forward (all modes),
clicking the '>>' button causes a small increment in speed (decrement
in minimum viewing time) for each click, and clicking the '<<' button
causes a small decrement in speed (increment in minimum viewing time).
Conversely, when in fast-backwards mode, clicking the '<<' button
causes a small increment in speed for each click, and clicking the
'>>' button causes a small decrement in speed.  These do not change
the minimum viewing time set in the preferences file.
   (6b) When in fast-forward or fast-backwards (all modes), clicking
any navigation button other than '>>' or '<<' causes exit from that
mode and viewing of the single frame implied by the button that was
clicked.
   (7) Metafile viewing should behave as follows:  On startup, the
program should read the first frame and display it immediately.  It
should then continue reading (but not displaying) frames in the
background until the number of frames specified by the in-memory
limit is reached (or, of course, fewer if the metafile contains
fewer than this number of frames).  The navigation buttons then
work within this set, except that, when located at the last in-
memory frame, the '>' button results in reading one more frame
(and discarding a frame (or frames when (9) is implemented) if
necessary); the '>>' button steps to the last frame if not already
located there, then continues reading new frames and deleting old
frames until stopped by a button as detailed above or by reaching
the end of the metafile.
   (8) I would like to have a GoTo button with an entry widget
where one can enter a frame number, whether in metafile or socket
mode.  If clicked while in socket-movie mode, frame updating is
handled as for the buttons described in item (6).  The frame num-
ber should count from the first frame in the metafile or socket
file, regardless of any frames that may have been discarded.  If
a frame is requested that is not available, a nice little beep
would be sufficient error message.  In the first phase, GoTo
would only access frames that are currently in memory.  A further
extension for the metafile case is given in item (10).
   The rules of inheritance are modified as follows:  Whenever
the user views frames in number order, i.e. using '<', '<<',
'>', or '>>' buttons, or in movie mode, each frame inherits
the window size (unless the aspect ratio changes due to the
frame size given in the file) and position, magnification,
origin offset, and background color of the most recently viewed
frame.  If 'GoTo' or '|<' is used to view a frame already viewed
that is not the immediate previous or next frame in frame number
order, then the parameters of that frame when it was most recently
viewed will apply.  If 'GoTo' or '>|' is used to view a frame not
already viewed (in a metafile), it should inherit from the highest-
numbered frame in memory that is below the requested frame.  If
implemented as in implementation suggestion (2) below, the inherited
values can also be stored with all of the unviewed frames that are
skipped over.
   When the frame size requested by a new frame command in the
input metafile or socket is different from the value that would
be inherited according to the above rules, the size in the
header takes precedence.  The current behavior is good the
way it is, please do not change it.
   (8a) The program should keep track of the order in which frames
are viewed when the user applies any of the controls mentioned above.
The size of this list should be a preference file item, with default
100 frames.  Each time the '<' button is clicked with the CTRL key
held down, the program goes to the next previous frame on this list,
i.e. undoes a GoTo.  Each time the '>' button is clicked with the
CTRL key held down, the program goes to the next frame moving forward
on this list.  See implementation suggestion (5).
   (9) We really need a command-line parameter that specifies the
maximum memory to be used for storing frame commands (as opposed
to the present setting of the maximum number of frames).  This
should not be an environment parameter.  If the guidelines are
implemented as outlined above, there is really no reason this
cannot be changed up or down (with some fixed minimum) during a
run via a right-click menu item.  There should be a default in
the preferences file that will be used if the command-line
parameter is not found at start up.

The following items (9a-d) refer to the interaction between frame
movement and memory restriction:

   (9a) Socket-still mode:  We always want to request from the
application just one more frame than the highest frame number ever
viewed.  The user can click Next and Previous and Goto ad lib anywhere
within what is in memory, but a new frame is requested from the
application only when the latest frame is viewed.  When memory fills,
lowest-numbered frames are thrown out until enough memory is freed
up.  This prevents creating gaps in the set of viewable frames.
When the user tries to use the Back or Goto button to go back to a
frame that has been removed, there is an error beep as already
mentioned above.
   Note that the situation I observed with the 9/11 version cannot
happen now, as long as you keep enough spare memory to receive one
new frame.  You will never be throwing away a frame except when the
latest frame is being viewed and when that happens, you will always
be throwing away just one or more of the earliest frames.  The user
will not be able to go back to those, but he/she will never see a
discontinuity within the stack of viewable frames.
   (9b) Socket-movie mode.  When in movie mode, either viewing
current frames or navigating, mfdraw requests frames from the
application until the memory quota is filled.  When the currently
viewed frame is more than half way through the cache of frames in
memory, and a new frame is received, mfdraw (a) removes old frames
if necessary to make enough memory to hold the new frame on the
list of frames that are recorded in the index, (b) puts a pointer
to the new frame in the index, (c) asks the application for another
frame, and (d) (if in true movie mode) displays the new latest one.
   (9c) [This paragraph deleted].
   (9d) Transition from still mode to movie mode:  With the current
frame positioned anywhere in the list of viewable frames, the user can
get to movie mode via the 'M' key or the right-click menu.  The first
thing that happens is that mfdraw requests a new frame from the
application if one is not already pending.  Then, if the currently
displayed frame is not the most recent frame, mfdraw quickly steps
through the frames in memory, as it does now, displaying each one for
a brief time (using the preference file minimum-time item) until the
displayed frame is the most recent frame.  Then it changes the global
switch to movie mode and continues as above.  No other special action
needed.
    Note that if the user does not desire stepping through all the
frames as described here, he/she need only press the '>|' button
before entering movie mode.
   (10) Regarding navigation when reading from a metafile on disk:
The new thing here is that we want to be able to use arrow keys and
Goto to access any frame in the metafile.  (This would not apply
when reading from a socket.)  This clearly requires being able to
reread frames that may have previously been discarded from memory.
Implementation suggestions are given below.

Implementation suggestions:

   (1) As we discussed, most of the above can be implemented via
an in-memory index that contains pointers to an area for each frame
that contains its plotting commands and any other information
needed for plotting, i.e. current scale, origin, and location.
If the index is a simple array of structs, then information about
frame x can be obtained quickly via index[x]->variable.
   (2) Regarding reading metafiles:  Supposing I add a data item
at the end of the metafile that records how many frames are in that
file, so you do not have to scan through to count them but can just
do a seek to the end of the file to read the number of frames; then
it seems to me you could allocate space for your index structures
for all the frames in the metafile, which we agree is not a lot of
memory, but populate those index structures only when the frames
are actually read, so there is not too long a startup delay.  When
the current memory limit is full, delete frames in order from least
recently viewed (see above) until the memory is below the limit.
   So, whether I go through starting at frame 1 and clicking Next
over and over, or use Goto and view in some crazy random order,
what the code has to do is go to the index, see if that frame is in
memory, if so, display it, if not, read it in and note in its index
slot that it is now in memory and where it is.
   One of the items in the index has to be the seek location of that
frame in the metafile.  If the user uses Goto to view frames out of
order, it may be necessary in this situation to scan through the
metafile from the last frame whose seek location is known to find
the requested frame.  The seek locations of the frames skipped over
can still be recorded in the index so these can be found quickly
when needed later.  This overhead will be unavoidable (it replaces
reading the entire metafile at startup as is done now), but will
be relatively rare in practice.
   (3) Reading from a socket.  Now we do not know in advance how
many frames there will be.  As we discussed on 9/12/07, you can
allocate index space, but not frame command space, for some large
number that is a compile-time constant, e.g. 10000.  I suppose
that if that number is ever exceeded, a realloc() would take care
of it (this requires that there be no pointers in the structs
that point to other items in the index--offsets must be used
instead so they do not have to change when a realloc() occurs)
or the program could keep the index as a circular list and when
full throw away old index entries along with the frames they
point to.
   (4) Note that if things are done this way, the memory limit can
be changed at any time.  The next time a new frame is requested, it
may result in throwing away a bunch of frames if the limit was
lowered, or in throwing away nothing for a while if it was raised.
   (5) The natural structure for the viewing-order list is a
circular buffer so that nothing except a pointer to the most-
recently viewed frame ever needs to be moved.  The only information
that needs to be stored in this list is the frame number, which
can be used to access frames via the master index.  The list is
updated when normal navigation is performed and is traversed,
but not updated, when the CTRL arrow buttons are used.  Clearly,
there is some special startup code needed to handle backtracking
when the list is not yet full.  Old entries are simply written
over when the list becomes full.

GNR

