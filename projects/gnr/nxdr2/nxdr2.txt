Specification for NXDR2 converter:

V1A, 10/23/92, ABP
Rev, 10/03/96, GNR
V2A, 09/12/99, GNR
V2C, 10/03/15, GNR
V2D, 02/05/16, GNR
V2E, 09/25/16, GNR - Add alignment info to 'j' code.

(NXDR = NSI eXternal Data Representation, as in SunOS XDR(3N)).

Synopsis: nxdr2 -f incfile -b objfile -c cmd \
   [-m32|-m64] [-t tpfx] [-o outfile] [-h hdrfile]

Purpose:
-------
nxdr2 takes a list of header files and a list of object types and
generates a set of conversion tables that specify type information for
for those objects.  These tables are used by the lab shared-memory
system (membcst(), etc.) and by the message-passing library (nncom(),
etc.).  The name nxdr2 indicates replacement of the obsolete version
1, which had a different set of inputs and outputs.

Why the new version:
-------------------
nxdr2 allows the application to deal with offsets to conversion tables
rather than with pointers to conversion tables.  These offsets can be
sent between processors with different address spaces, allowing the
memory management routines to provide automated data tree traversal.
Types ui16, si16, ui32, si32, and size_t have been added to the list
of recognized base types.  The new version also now allows nested
struct and union definitions, even within a typedef, and recognizes
"enum" as a base type equivalent to "int" (may require casting in
routines that use the tables generated by nxdr2).  There are no
restrictions on the lengths of identifiers that can be processed.
nxdr2 is designed to be able to handle any valid C program.

The following scheme is in place for handling messages passed between
processors with different memory models (base type lengths):  Each
base type has a length known on each processor via the 'sizeof' C
operator and a (possibly longer) length based on the longest length
that type has on any supported system.  nxdr2 uses single-letter codes
to identify the types of base items in the output nxdrtab.c table.
The client can determine the local length from the type code.  For all
key types, nxdrtab.c includes a total length based on the local item
lengths adjusted upwards if necessary for alignment and also a maximum
item length that may be used for structure alignment.  These lengths
are used by the allocp[cmr] family of routines for memory allocation
and are system dependent.  Therefore, nxdr2 now has command-line
options '-m32' and '-m64' which modify these tabulated lengths so that
conversion tables can be made for systems other than the one on which
nxdr2 runs.  (These alignments are conservative and sometimes give
lengths slightly longer than the result returned by sizeof.)  The base
item lengths for use in messages are given in the header file swap.h
in the form FMxSIZE where 'x' indicates the item type (e.g. 'I' for
integer).  The application is expected to expand smaller types to the
FMxSIZE length when building messages and to drop excess bits (with
overflow testing) when reading a message into a processor with smaller
types.

Arguments:
---------
-f incfile           "incfile" is the name of a file containing a
                     list of "#include" directives for all the header
                     files that contain definitions of objects listed
                     in the -b option.  If a dependency between files
                     exists, place the file containing the definition
                     of each object earlier in the list than any file
                     in which that object is used in another defini-
                     tion.  (With some compilers, it may be necessary
                     for incfile to have a .c suffix.)

-b objfile           "objfile" is the name of a file containing a list
                     of the key objects for which conversion tables
                     are to be generated.  One or more objects may be
                     named on each line, separated by whitespace.
                     Each object name consists of either one or two
                     words.  If the first word is "struct", "union",
                     or "enum", then the second word is interpreted as
                     the name of a C struct, union, or enum type.
                     Otherwise, the first word alone is the name
                     (typedef name).  The order of items in the list
                     is immaterial.  It is not necessary to list
                     built-in C type names (int, long, float, etc.)
                     or tag or typedef names that are referred to
                     inside a structured type but which do not
                     required their own named table.

-c cmd               The command line used for compiling the current
                     application, including all -I include directories
                     and -D macro definitions.  The command line must
                     be enclosed in double quotes.

-m32                 Indicates that lengths in output tables should be
                     derived from base type lengths for Linux 32-bit
                     systems.  The default is to use lengths for the
                     system on which nxdr2 was compiled.

-m64                 Indicates that lengths in output tables should be
                     derived from base type lengths for Linux 64-bit
                     systems.  The default is to use lengths for the
                     system on which nxdr2 was compiled.

[-t tpfx]            'tpfx' specifies the prefix used to generate the
                     output tables in the -o file.  The strings 'TT'
                     and 'UT' are appended to the prefix to generate
                     the names of the global conversion table and the
                     union conversion table, respectively.  The de-
                     fault table prefix is 'NXDR' and the two tables
                     are referred to as 'NXDRTT' and 'NXDRUT' in the
                     remainder of this document.  When generating
                     conversion tables for subroutine libraries,
                     this option should be used to specify strings
                     unique to each library to avoid conflicts with
                     tables generated for the application or other
                     libraries.

[-o outfile]         An optional file name (including path) for the
                     .c file generated by the program.  If the last
                     two characters in the file name are not ".c"
                     then these two characters will be appended to
                     the end of the name.  The default output file
                     name is "./nxdrtab.c".

[-h header file]     An optional file name (including path) for the
                     .h file generated by the program.  If the last
                     two characters in the file name are not ".h"
                     then these two characters will be appended to
                     the end of the name.  The default header file
                     name is "./nxdrdef.h"


Description:
-----------
nxdr2 invokes the C preprocessor on the specified incfile, using all
flags from the "cmd" argument to assure that proper "-D" definitions
are in effect.  The preprocessor output is then scanned according to
the object list and the rules described later to produce a conversion
table described later.  The table is written to the output .c file,
and #defines to locate the various table elements are written to the
output .h header file.  Externs to locate the actual tables must be
placed by the user where needed (typically only in nncom and membcst).

Usage:
-----
Several steps are involved in incorporation of nxdr2 into an
application:

-- Edit the application's makefile according to the items below.
Note that if the makefile uses different compiler commands to generate
different executables from the same source code, then each variant
should be considered separately, with different nxdr2 files for each
one.  The remainder of this section refers to one such 'application'.

   1. Start with a list of the objects that are to be translated.
      Make an "objfile" containing a list of all these objects.

   2. Make an "incfile" that contains "#include" directives for all
      the header files needed to define those objects--system and
      user-defined header files should be included.

   3. From the application's makefile, locate the command used
      for compiling the source files.

   4. Pick names for the 2 files generated by nxdr2, and, for
      libraries, pick a unique prefix for the table names.  As
      an example, we'll assume that the default names are used:

   nxdrtab.c -- the generated table, must reside with the rest of
                the application's source files.
   nxdrdef.h -- the generated defines, must reside with the rest
                of the application's header files.

   5. Add the files 'nxdrdef.h' and 'nxdrtab.c' to the list of
      source files that make up the application.

   6. Add the following lines to the makefile:

   nxdrdef.h nxdrtab.c:   <path and name of nxdr2> incfile objfile \
                <all the .h files included in incfile>
     nxdr2 <list of arguments>

   Note that the indentation in the last line must be a tab, not
   blanks.  If the make utility on your system has a means of analyzing
   header dependencies automatically, the list of .h files in the above
   rule can be omitted.

-- Write type conversion routines for all the unions in the application.
   Give them the names assigned by nxdr2, as defined below, and make the
   arguments conform to the prototype defined by the typedef 'unicvtf'
   in nsitools.h.

-- Edit all source files that allocate, reallocate, or free shared
   memory or that send messages between nodes to use the new functions
   and conversion table definitions.

Object rules:
------------
Objects may be any of the following:

1. Names of C predefined scalar types (e.g. int, float), size_t, and
   the types si16, ui16, si32, ui32, si64, ui64 defined in sysdef.h
   are included automatically in all cases and are not required.
2. Named structure types (e.g. "struct cellblk").
3. Named union types (e.g. "union uunm").
4. Named enum types (e.g. "enum cases").
5. Names created with a "typedef" statement.

The following restrictions apply:

1. The programmer must supply routines to convert all unions that are
   named in the -b file or that are contained within objects named in
   the -b file.  All such unions must have tag or typedef names so the
   "sizeof" operator can be applied to find their size.  nxdr2 will
   create a "jump" entry in the conversion table which will cause the
   table interpreter to call a routine with a name generated from the
   name of the union.  More discussion of this follows.

2. Function definitions cannot be translated.  Pointers to functions
   included in typedefs or structured data types will be processed
   and coded as pointers in the conversion tables produced by nxdr2.
   However, membcst() and nncom() will not be able to translate
   function pointers to point to the correct function on the receiving
   processor.

3. Conditional compilation that would change the types and numbers of
   elements within a data structure on different processors must be
   avoided (but the base types may have different lengths).  This
   error cannot be detected by nxdr2.

4. (The restrictions in the original nxdr regarding identifier lengths
   and nested struct or union definitions have been removed.)

Output of nxdr2:
---------------
nxdr2 generates a .c file containing a global conversion table named
'tpfxTT' ('NXDRTT' by default).  There is an entry in this table for
each type listed in the file specified by the '-b' command line option
and for nonunique anonymous objects contained within these objects.
Each table entry comprises an array of long word entries as described
below.  The table entries do not have individual names; they are
accessed using the offsets given as "#defines" in the output .h file.

The .c file also contains a table of pointers to the union conversion
routines that the user must write (if any).  This table is named
'tpfxUT' ('NXDRUT' by default).
  
The offset to each table entry is defined in the .h output file as
the actual offset + 0x80000000L; positive values are used by the
allocp* family of routines as block sizes for unstructured data.
The names assigned to the table offsets in the .h output file are
derived according to the following rules:

Type name          Offset name       Example
-------------------------------------------------
<typedefname>      IX<typedefname>   IXcomplex
enum <ename>       IXenu_<ename>     IXenu_days
struct <sname>     IXstr_<sname>     IXstr_celldata
union  <uname>     IXuni_<uname>     IXuni_datcol

Table entries comprise a series of two or more long words.  There
are no entries for the built-in or base types (int, long, etc.).

Each entry for a key name (name included in the -b object file) or a
structure or union enclosed within a key name object, begins with a
word giving the full size of an object of that type (on the machine
where nxdr2 was compiled or as modified by the -m32 or -m64 command-
line options).

If the type is a typedef name, the total length is followed by a word
or word pair that defines the object and gives a count as described in
the table "Item Definitions" below.

If the type is a structure type, the total length is followed by a
long containing an expression of the form "(mxlen<<8) | 's'", where
'mxlen' is the length of the longest item in the structure, used by
the library routines to align the structure on an appropriate
boundary.  This value may vary on different systems, as described
above for the total length.  This is followed by item definitions
for the items in the structure.

If the type is a union, the entry for the union as a whole is preceded
by individual entries for the union members, which may in turn be
structures, embedded unions, or simple data elements.  The entry for
each union element begins with a total-length word as for key names,
followed by item definitions for the items in the union element.  Each
union member is given a name consisting of the name for the parent
union followed by "_1", "_2", etc.  for successive elements.

The entry for a parent union (or union member that is itself a union)
is the same as the item definition for an enclosed union as described
below:  There are two full words.  The first has the type code 'j'
and the repetition count (number of objects of the union type).  The
second has the alignment size in the low order 8 bits and the index
number of the union in the NXDRUT table in the high order 24 bits
(32-bit systems) or 56 bits (64-bit systems).

Item Definitions
---- -----------
The following codes are used to describe simple base types and base
types, structures, or unions included as members of structures:

- If the item is a simple base type, the entry is an expression of the
  form "(count<<8) | type", where 'type' is a one-letter code denoting
  the base type (see below), and 'count' is the number of consecutive
  items of that type in the object.

- If the item is an enclosed structure, the entry comprises two longs.
  The first is an expression of the form given above for simple base
  types, but with 'type' code 'x'.  This word gives the count of the
  number of times the enclosed structure is repeated in the outer
  structure.  The second long is the word offset in the NXDRTT table
  c of a conversion table that describes the enclosed structure.

- If the item is an enclosed union, the entry comprises two longs.
  The first is an expression of the form given above for simple base
  types, but with type code 'j'.  This word gives the count of the
  number of times the enclosed union is repeated in the outer struc-
  ture.  The second word has the alignment size in the low order 8
  bits and the index number of the union in the NXDRUT table in the
  high order 24 bits (32-bit systems) or 56 bits (64-bit systems).

All the entries but the last in each table use lower-case letters to
indicate that more entries follow.  The type code in the last entry
is an upper-case letter.

Scalar and array objects of base types always have a conversion array
of size one, whereas structured objects typically have more (except
for the case of a struct with all fields being of the same type).

The meanings of the various type codes are as follows (the lengths
given here are the possible lengths of the items on different proces-
sors.  Their lengths in files and messages are the larger of these
values.  Note that relative to the original nxdr, codes 'E', 'K', 'N',
'Y', and 'Z' have been added and the meaning of codes 'S' and 'W' has
changed.  Types 'B', 'W', and 'Y' are coded as base types even though
they may be defined by typedefs ('byte', 'si64', and 'ui64',
respectively, in sysdef.h or other header files):

    'B'    -   Unsigned character, 8 bits.
    'C'    -   Character, 8 bits.
    'D'    -   Double, 64 bits.
    'E'    -   Enum, 8, 16, or 32 bits.
    'F'    -   Float, 32 bits.
    'H'    -   Short integer, 16 bits.
    'I'    -   Integer, 32 bits.
    'J'    -   Jump to another conversion routine to handle a union.
               The next word gives the index of a pointer to this
               routine in the NXDRUT table and the alignment size.
    'K'    -   Jump to another conversion routine to handle a union.
               This entry is followed by two words.  The first gives
               the size of the largest variable in the union and the
               second is a direct pointer to the conversion routine.
               This pointer may have the length of one or two longs.
               Code 'K' is for use in hand-coded conversion tables
               and is never generated by nxdr2.
    'L'    -   Long integer, 32 or 64 bits.
    'M'    -   Unsigned short integer, 16 bits.
    'N'    -   Unsigned long integer, 32 or 64 bits.
    'P'    -   Pointer, 32 or 64 bits.
    'S'    -   Compound type.  The count is always one and the count
               field instead encodes the alignment boundary.  Put at
               the start of the table for any struct or union that
               contains data of more than one base type.
    'U'    -   Unsigned integer, 32 bits.
    'V'    -   Void - taken to be same as pointer.
    'W'    -   Signed long long integer, 64 bits.
    'X'    -   Execute another table, the offset of which is given in
               the next word.  To convert the current field, call the
               interpreter recursively with that table as its argument,
               'count' times.
    'Y'    -   Unsigned long long integer, 64 bits.
    'Z'    -   'size_t' system-defined type, 32 or 64 bits.


Examples (NXDRTT[xxx & MBTMask] indicates one or more entries beginning
at offset xxx in the NXDRTT table, where MBTMask is a mask defined in
header memshare.h that isolates the offset from other control bits):

NXDRTT[IXstr_CLSTAT & MBTMask] =
   216,                         /* str_CLSTAT */
   ( 8 << 8 ) | 's',
   ( 4 << 8 ) | 'w',
   ( 45 << 8 ) | 'L',

This is the table for the type "struct CLSTAT".  This is a structure
containing 4 si64 values and 45 longs, for a total length of 216 bytes
after alignment to a multiple of 8 ('s' code).  The table may be read
as "convert a 64 bit integer 4 times, then a long 45 times".

NXDRTT[IXstr_REPBLOCK & MBTMask] =
   100,                         /* str_REPBLOCK */
   ( 4 << 8 ) | 's',
   ( 4 << 8 ) | 'p',
   ( 1 << 8 ) | 'x',
   ( 553 ),
   ( 3 << 8 ) | 'n',
   ( 4 << 8 ) | 'c',
   ( 4 << 8 ) | 'f',
   ( 1 << 8 ) | 'u',
   ( 3 << 8 ) | 'i',
   ( 1 << 8 ) | 'm',
   ( 4 << 8 ) | 'h',
   ( 3 << 8 ) | 'm',
   ( 1 << 8 ) | 'm',
   ( 2 << 8 ) | 'B',

This is the table for the type "struct REPBLOCK".  This structure
begins with 4 pointers, followed by an embedded anonymous structure,
3 unsigned longs, 4 characters, and so on.  Note the line with code
'x', which means:  "Convert 1 times according to table at offset 553
in NXDRTT.  When space for this structure is allocated, the memory
management routines will use the 's' entry with value '4' (the size of
the largest element in the struct) to align the structure if alignment
is required on the host where the program is running, otherwise this
information will be ignored.

Handling of unions:
------------------
The conversion of a union requires knowledge of its current "state",
i.e.  which of its appearances is currently valid.  The strategy for
dealing with this is as follows:

--nxdr2 creates a type and a conversion table entry for each of the
appearances.  These types are named by concatenating the name of the
union with the string _x, where x is a counter for each appearance,
starting with _1.

--nxdr2 creates a prototype for a hand-written conversion routine for
the union.  The interface to all union conversion routines is defined
by the typedef 'unicvtf' in mpitools.h.  Please note that you cannot
use a typedef type in a function definition, so the actual code for
the function must not explicitly mention the unicvtf type, but must
just declare the same arguments as given in the unicvtf definition.
These arguments include a pointer to the object enclosing the union,
so the conversion routine can check relevant fields to decide about
the correct conversion.  The conversion routine can also make use of
global variables or data in structures pointed to from within the
parent structure to determine the state of the union.  It is also
permissible for the union conversion routine running on the host to
send information to its counterparts running on comp nodes by using
nnput()/nnget() calls via the broadcast stream passed in the first
argument to the unicvtf routine.

--The conversion routine will decide on an appearance and either
perform the conversion directly or recursively call the conversion
routine that called it (e.g. nncom()) with the offset of the correct
table of the _x family.

Example:

The union exun contains three instances defined as follows:

union exun {
   struct {
      float f1a[7];
      int i1;
      float f1b;
      } exun1;
   struct {
      float f2a[7];
      int i2[4];
      } exun2;
   struct {
      int i3[4];
      } exun3;
   }

This is the output produced by nxdr2:

At NXDRTT[IXuni_exun_1 & MBTMask]:
   36,
   ( 7 << 8 | 'f'),
   ( 1 << 8 | 'i'),
   ( 1 << 8 | 'F'), ...

At NXDRTT[IXuni_exun_2 & MBTMask]:
   44,
   ( 7 <<8 | 'f'),
   ( 4 <<8 | 'I'), ...

At NXDRTT[IXuni_exun_3 & MBTMask]:
   ( 4 <<8 | 'I'), ...

At NXDRTT[IXuni_exun & MBTMask]:
   44,
   ( 1 << 8 | 'j'),
   ( 0 << 8 | 4 ), ...

extern unicvtf *NXFuni_exun_u;

unicvtf *NXDRUT[] = {
   NXFuni_exun_u,
   ...
   };

The tables NXDRTT[IXuni_exun_x & MBTMask], where x goes from 1 to 3,
describe the elements of the union.  The programmer must hand-code the
function NXFuni_exun_u(), because only hand code can determine which
instance of the union is currently valid.  This routine can call
nncom() with a pointer to the proper element table to transmit the
selected element.  The length of each variant of the table is set to
its own length, but its alignment length is not given, because it is
the same as the alignment length for the union as a whole.  The total
length of the union as a whole is the length of the longest variant,
i.e the size needed by the allocation routines and the size used by
nncom() to advance to the next item after the union.

Conversion function:
-------------------

The function nncom() in the mpitools library combines the functions of
converting a structure to or from message format and sending or receiv-
ing it on a link to/from another node in a processor array.  There is
currently no standard library routine to perform conversion without
message passing.

Temporary files:
--------- -----

While it is running, nxdr2 creates several temporary files in the
current working directory.  At normal termination, these files are
erased.  When an abnormal termination (error exit) occurs, one or
more of the temporary files may be left behind because they may
contain information that is useful for diagnosing the error.  The
files should be erased when no longer needed, or they will be erased
automatically the next time nxdr2 is run in that directory.  The
temporary files are as follows:

File Name     Function
---- ----     --------
$runcpp$      Runs the C preprocessor
<header>.i    Output of C preprocessor, where <header> is the name
              of the -f input file minus any .c or .h tail.
$nxdr$.c      C program generated to evaluate an array dimension
              expression.
$nxdr$.o      Output of $nxdr$.c compilation.
$nxdr$        Executable made from $nxdr$.c.
$nxdr$.t      Output from executing above file.
$nxdr$.tt     Standard output from running cpp or C compiler.
