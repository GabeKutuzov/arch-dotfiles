/* (c) Copyright 1992-2017, The Rockefeller University *21116* */
/* $Id: d3ucvt.c 76 2017-12-12 21:17:50Z  $ */
/***********************************************************************
*                          CNS-Hybrid Program                          *
*                              d3ucvt.c                                *
*               NXDR functions for conversion of unions                *
*                                                                      *
*  This file contains human-written functions for converting all       *
*  unions that occur in hybrid system interprocessor messages to       *
*  the standard message format.  In general, these functions are       *
*  used to decide the current type contained in the union, based       *
*  usually on data in the containing structure, and then to call       *
*  the general purpose converter routine nncom() with the proper       *
*  conversion table for the current type of the union.                 *
*                                                                      *
*  The name of each function below is generated automatically by       *
*  nxdr2, which concatenates the string 'NXFuni_' to the name of the   *
*  union, followed by "_u".   For example, the structure CELLTYPE      *
*  includes the union CTctwk.  The name of the conversion function     *
*  for this union is 'NXFuni_CTctwk_u'.  To verify a function name,    *
*  one may look in the file d3nxtab.c generated by nxdr2.              *
*                                                                      *
*  For each appearance of a union, nxdr2 generates a conversion table. *
*  A variable defining the offset of each conversion table in NXDRTT   *
*  is generated by the same rules as other (non union) tables, i.e.    *
*  the name of the generated variable is 'IXuni_uuuu_n', where 'uuuu'  *
*  is the name of the union and n = 1,2,3,.... is incremented for      *
*  every appearance of the union.  For the union given in the example  *
*  above, five tables are generated, at offsets IXuni_CTctwk_1, ...    *
*  IXuni_CTctwk_5.  Again, one may use the d3nxdr.h header file to     *
*  verify names.                                                       *
*                                                                      *
*  The union conversion routines are all of type 'unicvtf', which is   *
*  defined in mpitools.h.  The arguments are discussed further in      *
*  nncom.c.                                                            *
*                                                                      *
*  The following is a skeleton for a union conversion routine:         *
*  (Note that although the type of this routine is defined as          *
*  'unicvtf', ANSI C requires that a function declaration does not     *
*  inherit any typedefs.   This is unfortunate, since whenever the     *
*  definition of 'unicvtf' changes, all the function declarations      *
*  below must be changed to match that).                               *
*                                                                      *
*  void funame(struct NNSTR *pnn, void **ppobj, void *parent,          *
*             int flags) {                                             *
*                                                                      *
*     long *ptable;                                                    *
*     char *pso;                                                       *
*                                                                      *
*     -Use fields in the parent block 'parent' to determine the        *
*        correct appearance of the union, and assign to 'ptable'       *
*        the address of the table for that appearance.                 *
*        N.B.  The variable that defines the current appearance of the *
*        union must occur in the parent before the union itself, so    *
*        that it is transferred to comp nodes before the jump code.    *
*     -Save union address *ppobj in pso.                               *
*     -If the contents of the union are irrelevant, skip to the        *
*        next step.  If the contents are to be transmitted with        *
*        no conversion (byte array), use nnget or nnput, depending     *
*        on the 'flags' argument.  In the normal case, call nncom()    *
*        recursively to convert and transmit the data, e.g.            *
*        nncom(pnn, ppobj, ptable, flags).  nncom() will terminate     *
*        if it finds any errors.                                       *
*     -Set *ppobj to (pso + sizeof(the union));                        *
*     }                                                                *
*                                                                      *
************************************************************************
*  Initial Version, 11/30/92 - ABP, GNR.                               *
*  Rev, 07/01/93, ABP - Add blen and option for 'byte array', fix bug  *
*  V6D, 02/18/94, GNR - Add conversion for CELLTYPE_ctwk for d3rstr    *
*  V7B, 08/20/94, GNR - Revise conversion of ucij for bilinear Cij     *
*  V7C, 01/29/95, GNR - Add 'q' struct to ul2 for KGEN=Q               *
*  V8A, 08/20/96, GNR - Fix conversion for MODALITY_um1, CELLTYPE_ctwk *
*  Rev, 10/04/96, GNR - Add conversions for MODVAL_umds, MODBY_umve    *
*  Rev, 11/26/96, GNR - Remove support for non-hybrid version          *
*  Rev, 07/26/98, GNR - Remove hhcom return code testing               *
*  V8B, 12/16/00, GNR - Complete rewrite for nncom()                   *
*  V8D, 03/27/05, GNR - Add conductances and ions                      *
*  ==>, 08/21/07, GNR - Last mod before committing to svn repository   *
*  V8I, 02/09/13, GNR - Add du1 union in DECAYDEF block                *
*  Rev, 04/20/13, GNR - Add iu1 union in INHIBBLK block                *
*  R66, 02/05/16, GNR - Remove iu1 union                               *
*  R67, 10/05/16, GNR - Bug Fix:  Variable in parent that defines      *
*                       appearance must come before the union!         *
*  R72, 02/06/17, GNR - Add k structure to CNul1 union                 *
***********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include "sysdef.h"
#include "d3global.h"

/*--------------------------------------------------------------------*/
void NXFuni_DCDu1_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   long *ptable;        /* Pointer to conversion table */
   char *pso = *ppobj;  /* Pointer to start of object (union) */
   struct DECAYDEF *pdcd = (struct DECAYDEF *)parent;

   /* Set 'ptable' to point to the appropriate conversion table */
   switch (pdcd->kdcy) {
   case NODECAY:
   case DCYEXP:
   case DCYLIM:
      ptable = NULL;
      break;
   case DCYSAT:
      ptable = ttloc(IXuni_DCDu1_2);
      break;
   case DCYALPH:
      ptable = ttloc(IXuni_DCDu1_3);
      break;
   case DCYDBLE:
      ptable = ttloc(IXuni_DCDu1_1);
      break;
      } /* End kcond switch */

   /* Call nncom() with the selected table */
   if (ptable)
      nncom(pnn, ppobj, ptable, flags);

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union DCDu1);

   }

/*--------------------------------------------------------------------*/
void NXFuni_CDUn1_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   long *ptable;        /* Pointer to conversion table */
   char *pso = *ppobj;  /* Pointer to start of object (union) */
   struct CONDUCT *pcnd = (struct CONDUCT *)parent;

   /* Set 'ptable' to point to the appropriate conversion table */
   switch (pcnd->kcond) {
   case CDTP_PASSIVE:
      ptable = NULL;
      break;
   case CDTP_LINEAR:
      ptable = ttloc(IXuni_CDUn1_1);
      break;
   case CDTP_ALPHA:
      ptable = ttloc(IXuni_CDUn1_2);
      break;
   case CDTP_DOUBLE:
      ptable = ttloc(IXuni_CDUn1_3);
      break;
      } /* End kcond switch */

   /* Call nncom() with the selected table */
   if (ptable)
      nncom(pnn, ppobj, ptable, flags);

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union CDUn1);

   }

/*--------------------------------------------------------------------*/
void NXFuni_CDUn2_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   long *ptable;        /* Pointer to conversion table */
   char *pso = *ppobj;  /* Pointer to start of object (union) */
   struct CONDUCT *pcnd = (struct CONDUCT *)parent;

   /* Set 'ptable' to point to the appropriate conversion table */
   switch (pcnd->kactv) {
   case CDAC_CELLFIRE:
   case CDAC_SYNAPTIC:
      ptable = ttloc(IXuni_CDUn2_3);
      break;
   case CDAC_IONIC:
      ptable = ttloc(IXuni_CDUn2_1);
      break;
   case CDAC_POISSON:
      ptable = ttloc(IXuni_CDUn2_2);
      break;
      } /* End kactv switch */

   /* Call nncom() with the selected table */
   if (ptable)
      nncom(pnn, ppobj, ptable, flags);

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union CDUn2);

   }

/*--------------------------------------------------------------------*/
void NXFuni_CDUn3_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   char *pso = *ppobj;   /* Ptr to start of object for update */

   /* No values should be transmitted for this union */

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union CDUn3);

   }

/*--------------------------------------------------------------------*/
void NXFuni_CNcnwk_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   char *pso = *ppobj;   /* Ptr to start of object for update */

   /* There is no need to transmit any values for this union */

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union CNcnwk);

   }

/*--------------------------------------------------------------------*/
void NXFuni_CNucij_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   long *ptable;        /* Pointer to conversion table */
   char *pso = *ppobj;  /* Pointer to start of object (union) */

   struct CONNTYPE *ix = (struct CONNTYPE *)parent;

   /* Set 'ptable' to point to the appropriate conversion table */
   if (ix->kgen & KGNLM)
      ptable = ttloc(IXuni_CNucij_2);
   else if (ix->kgen & KGNTW)
      ptable = ttloc(IXuni_CNucij_3);
   else if (ix->kgen & KGNMC)
      ptable = ttloc(IXuni_CNucij_4);
   else
      ptable = ttloc(IXuni_CNucij_5);

   /* Call nncom() with the selected table */
   nncom(pnn, ppobj, ptable, flags);

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union CNucij);

   }

/*--------------------------------------------------------------------*/
void NXFuni_CNul1_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   long *ptable;        /* Pointer to conversion table */
   char *pso = *ppobj;  /* Pointer to start of object (union) */
   struct CONNTYPE *ix = (struct CONNTYPE *)parent;

   /* Set 'ptable' to point to the appropriate conversion table */
   if (ix->kgen & (KGNGP|KGNG1|KGNHG|KGNJN|KGNND|KGNOG|KGNUD))
      ptable = ttloc(IXuni_CNul1_1);
   else if (ix->kgen & (KGNTP|KGNFU|KGNST))
      ptable = ttloc(IXuni_CNul1_2);
   else if (ix->kgen & KGNHV)
      ptable = ttloc(IXuni_CNul1_3);
   else if (ix->kgen & (KGNXO|KGNYO))
      ptable = ttloc(IXuni_CNul1_4);
   else
      ptable = NULL;

   /* Call nncom() with the selected table */
   if (ptable)
      nncom(pnn, ppobj, ptable, flags);

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union CNul1);

   }

/*--------------------------------------------------------------------*/
void NXFuni_CNul2_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   long *ptable;        /* Pointer to conversion table */
   char *pso = *ppobj;  /* Pointer to start of object (union) */
   struct CONNTYPE *ix = (struct CONNTYPE *)parent;

   /* Set 'ptable' to point to the appropriate conversion table */
   if      (ix->kgen & (KGNAJ|KGNBV))
      ptable = ttloc(IXuni_CNul2_1);
   else if (ix->kgen & KGNBL)
      ptable = ttloc(IXuni_CNul2_2);
   else if (ix->kgen & KGNKN)
      ptable = ttloc(IXuni_CNul1_3);
   else if (ix->kgen & KGNPT)
      ptable = ttloc(IXuni_CNul2_4);
   else if (ix->kgen & KGNAN)
      ptable = ttloc(IXuni_CNul2_5);
   else
      ptable = NULL;

   /* Call nncom() with the selected table */
   if (ptable)
      nncom(pnn, ppobj, ptable, flags);

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union CNul2);

   }

/*--------------------------------------------------------------------*/
void NXFuni_CTctwk_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   char *pso = *ppobj;  /* Pointer to start of object (union) */

   /* For this union, we really only care about the phs1 contents,
   *  which must appear on all nodes for d3rstr.  So just use that
   *  conversion all the time.  */
   nncom(pnn, ppobj, ttloc(IXuni_CTctwk_2), flags);

   /* Update *ppobj eto reflect union size */
   *ppobj = pso + sizeof(union CTctwk);

   }

/*--------------------------------------------------------------------*/
void NXFuni_MOu1_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   char *pso = *ppobj;  /* Pointer to start of object (union) */

   /* For this union, we really only care about the MS contents,
   *  so just use that conversion all the time.  */
   nncom(pnn, ppobj, ttloc(IXuni_MOu1_1), flags);

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union MOu1);

   }

/*--------------------------------------------------------------------*/
void NXFuni_MVu1_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   char *pso = *ppobj;   /* Ptr to start of object for update */

   /* No values should be transmitted for this union */

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union MVu1);

   }

/*--------------------------------------------------------------------*/
void NXFuni_VBu1_u(
      struct NNSTR *pnn, void **ppobj, void *parent, int flags) {

   long *ptable;        /* Pointer to conversion table */
   char *pso = *ppobj;  /* Pointer to start of object (union) */
   struct VBDEF *pv = (struct VBDEF *)parent;

   /* Data for repertoire types need conversion, all others are
   *  computed only on host and conversion can be skipped.  */
   switch (pv->vbkid) {
      case VBK_REP:
         ptable = ttloc(IXuni_VBu1_1);
         break;
      default:
         ptable = NULL;
      } /* End switch */

   /* Call nncom() with the selected table */
   if (ptable)
      nncom(pnn, ppobj, ptable, flags);

   /* Update *ppobj to reflect union size */
   *ppobj = pso + sizeof(union VBu1);

   }

