/* (c) Copyright 2007-2018, The Rockefeller University *11116* */
/* $Id: bbdcinit.c 30 2018-08-15 19:46:51Z  $ */
/***********************************************************************
*                      BBD (Client Side) Package                       *
*                             bbdcinit.c                               *
*         Initialize communication with a network simulation           *
*                                                                      *
*  This routine may be called by an independently running application  *
*  such as a real or virtual BBD to establish communication with the   *
*  cortical network simulator, CNS, in order that CNS may provide      *
*  network services for the BBD.  It is assumed that inetd has been    *
*  set up on the target system to listen on the assigned port and      *
*  start CNS when a request is received.                               *
*                                                                      *
*  Synopsis:                                                           *
*  int bbdcinit(char *phost, ui32 port, char *pctrl, char *plog)       *
*  int bbdciniv(char *phost, ui32 port, char *pctrl, char *plog,       *
*     int who);                                                        *
*                                                                      *
*  bbdciniv() is a wrapper for bbdcinit() that causes the CNS server   *
*  to be informed that the client plans to call bbdcgetm() to obtain   *
*  the current running version information for CNS.  This will cause   *
*  CNS to return that information in a message immediately following   *
*  the bbdschk() call.  (This mechanism assures compatibility with     *
*  earlier versions of clients that know nothing about bbdcgetm().)    *
*                                                                      *
*  Arguments:                                                          *
*     phost    Ptr to a string giving the name of the host where the   *
*              network simulation is to be run followed by a semicolon *
*              and the IP address or resolvable name of this client    *
*              host.  NULL indicates that the simulation is to be run  *
*              on the calling host.  (See note below.)                 *
*     port     Number of the port to be used to initiate communication *
*              with CNS.  Normally, or if coded as 0, this will be the *
*              default port taken from the bbd.h header file. The next *
*              higher-numbered port will be used for data exchange.    *
*     pctrl    Ptr to a string giving the name of a valid CNS control  *
*              file.  This file will be read and presented to CNS on   *
*              its standard input.  It is assumed that this file will  *
*              contain all necessary parameters and options to set up  *
*              CNS appropriately for the application and will end with *
*              a CYCLE card that will allow CNS to run indefinitely    *
*              until stopped by a suitable event.  (If it contains an  *
*              EXECUTE card, the file to be executed must be access-   *
*              ible on the host where CNS is running.)                 *
*     plog     Ptr to the name of a file that can be opened for        *
*              writing a log.  Because the BBD calling application     *
*              has no use for any printed output generated by CNS      *
*              (which is under control of options in the pctrl file),  *
*              bbdcinit() spawns a subprocess that copies any such     *
*              data to the specified log file.  Writing commences at   *
*              the start of the file, destroying any previous data.    *
*              If plog is a NULL pointer, the log data are discarded.  *
*     who      [bbdciniv() only].  OR of bits indicating to which      *
*              clients the version info message should be sent.        *
*              (Define these bits in the order the client sockets      *
*              are defined in the setup process--1 for the first       *
*              client, 2 for second client, etc., up to 16 clients.    *
*              Add the bit NOMINPLOG (0x10000) to omit setting up a    *
*              bbdcminp log file in /var/tmp.)                         *
*                                                                      *
*  Return value:                                                       *
*     0        Operation successful, CNS may be used.                  *
*                                                                      *
*  Note re setup of second socket interface:                           *
*     Some thought was given to how one might automate the sending of  *
*  the correct callback IP address to CNS so manual intervention would *
*  not be required every time DHCP hands out a new host address.  How- *
*  ever, it was considered desirable to make this program as much as   *
*  possible independent of what OS it might be running, so the problem *
*  was pushed back to the caller via the requirement for both server   *
*  and client host names or IPs in the first calling argument.         *
*                                                                      *
*  Error Handling:                                                     *
*     All errors are terminal and result in a call to abexit() with a  *
*  suitable message.  There is nothing useful the caller can do.  The  *
*  client application should include versions of abexit(), abexitm(),  *
*  and abexitme() if there are any necessary shutdown actions they     *
*  must perform beyond what is in the standard libcrk.                 *
*                                                                      *
*  Implementation Note:                                                *
*     This program calls signal() to ignore SIGPIPE signals.  This is  *
*  to allow read() calls on the pipe to report errors, rather than     *
*  just get the application terminated (although the default action    *
*  according to one source at least, is ignore anyway).  Obviously,    *
*  if we eventually need a signal handler for some pipe signals and    *
*  not others, a more global way of controlling this will be needed.   *
*     Semaphores were added to allow bbdcchk to find out that either   *
*  of the subprocesses failed to start (missing executable)--the       *
*  BBDcd->Mlogrc test fails and rfopen() hangs forever if the bad      *
*  child process did not exit before the main process arrived at       *
*  bbdcchk().                                                          *
************************************************************************
*  This file also contains bbdcwait, which is used to wait for CNS to  *
*  terminate, and support routines bbdcstopsig and bbdcquit, which     *
*  should not be called direcly by the BBD user.                       *
************************************************************************
*  V1A, 02/01/07, GNR - New program                                    *
*  ==>, 02/02/08, GNR - Last mod before committing to svn repository   *
*  Rev, 08/14/08, GNR - Bug fix:  Send MY address to CNS, not his!     *
*  Rev, 11/17/08, GNR - Add call to ignore SIGPIPE to get err msgs     *
*  V1C, 11/09/10, GNR - Use separate bbdcmlog and bbdcminp excutables  *
*                       so abexits can write to log, semaphores and    *
*                       better termination checking (from mex version) *
*  Rev, 01/15/11, GNR - Other changes in error checking from mex vers. *
*  Rev, 05/07/13, GNR - Wait for LogProc instead of killing it         *
*  R30, 08/04/18, GNR - Remove SUNOS support, fix lnm uninit warning   *
***********************************************************************/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#define __USE_GNU
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <semaphore.h>

#define MINP_ERR_FILE "/var/tmp/bbdcminp.error.log"

#include "sysdef.h"
#include "bbd.h"
#include "rfdef.h"
#include "rksubs.h"

struct BBDComData BBDcd;               /* Common BBD data struct */
extern int h_errno;                    /* Not in CentOS 6 headers */

/*=====================================================================*
*                              bbdcwait                                *
*                                                                      *
*  This routine may be called by the application when it wishes to     *
*  wait until CNS finishes, rather than terminate at once via a call   *
*  to exit, which runs bbdcquit to kill CNS from this end.             *
*                                                                      *
*  Usage: void bbdcwait(void)                                          *
*=====================================================================*/

void bbdcwait(void) {

   int bbdstat;

   waitpid(BBDcd.LogProc, &bbdstat, 0);

   } /* End bbdcwait() */


/*=====================================================================*
*                              bbdcquit                                *
*                                                                      *
*  This routine is registered via atexit() to run when exit() is       *
*  called.  It shuts down CNS if not already dead, closes files,       *
*  and returns to the regular shutdown process.                        *
*=====================================================================*/

void bbdcquit(void) {

/* If Mlogrc is < 0, it means CNS has not yet terminated and
*  this program must tell it to quit.  There are three subcases:
*  (1) CNS already entered the CYCLE loop.  It can be shut down
*      via a special code sent in place of the usual sensor data.
*  (2) InpProc finished sending the input file, but bbdcchk was
*      not entered yet or is waiting on the rfopen(ndrecv).  CNS
*      is not responding but didn't send a terminal error msg.
*      This is an unusual case, maybe CNS is in a debug wait loop,
*      and there is no obvious way to kill it from here.  Just
*      give the user a message to kill CNS manually.
*  (3) CNS is still processing the input file.  It can be shut
*      down by just sending it an END card.  */

   if (BBDcd.Mlogrc < 0) {

      if (BBDcd.Minprc >= 0) {
         if (!BBDcd.ndsend) {
            /* Case (2):  No escape now.  */
            fputs("CNS is not responding.  Kill it manually!\n",
               stderr);
            fflush(stderr); }
         else {
            /* Case (1):  Send a control integer larger than
            *  BBDLC_MASK, viz. BBDLC_TERM  */
            rfwi2(BBDcd.ndsend, BBDLC_TERM);
            rfflush(BBDcd.ndsend, NOMSG_ABORT);
            }
         }
      }

   /* Case (3) above ends up here anyway */
   if (BBDcd.InpProc) {
      kill(BBDcd.InpProc, SIGTERM);
      rksleep(1, 0);
      BBDcd.InpProc = 0;
      }

   if (BBDcd.LogProc) {
      int LogStatus = 0;
      waitpid(BBDcd.LogProc, &LogStatus, 0);
      if (LogStatus < 0) {
         fputs("Error in wait for LogProc\n", stderr);
         fflush(stderr); }
      BBDcd.LogProc = 0;
      }

/* Now CNS should have terminated.  Code could be inserted here
*  to free all malloc memory, but the operating system should do
*  that perfectly well.  So now just close remaining open files
*  and that's all folks.  */

   if (BBDcd.ndsend)
      rfclose(BBDcd.ndsend, REWIND, RELEASE_BUFF, NOMSG_ABORT);
   if (BBDcd.ndrecv)
      rfclose(BBDcd.ndrecv, REWIND, RELEASE_BUFF, NOMSG_ABORT);

/* Get rid of semaphores */

   sem_close(BBDcd.pMinpSem);
   sem_close(BBDcd.pMlogSem);
   sem_unlink(MinpSemNm);
   sem_unlink(MlogSemNm);

   /* return, not exit--exit() has already been called somewhere */
   return;

   } /* End bbdcquit() */


/*=====================================================================*
*                             bbdcchldsig                              *
*                                                                      *
*  Routine to handle a SIGCHLD received by the main process.  This     *
*  routine must distinguish between termination of the mlog vs minp    *
*  processes and set the appropriate flag in the BBDcd data structure  *
*  so the main program can quit at the next nondangerous location.     *
*  If it was some other process (part of Allegro?) this routine does   *
*  not do a wait on it so as not to interfere with code elsewhere.     *
*  Post semaphores so bbdcchk can proceed if waiting for subprocs but  *
*  ignore errors because this is a signal handler.                     *
*=====================================================================*/

static void bbdcchldsig(int signum) {

   int status,rc;

   /* Was it the log process? */
   while (BBDcd.LogProc) {
      rc = waitpid(BBDcd.LogProc, &status, WNOHANG);
      if (rc == 0) break;
      if (rc == -1 && errno == EINTR) continue;
      BBDcd.LogProc = 0;
      if (WIFEXITED(status))
         BBDcd.Mlogrc = WEXITSTATUS(status);
      else
         BBDcd.Mlogrc = 102;
      if (BBDcd.Mlogrc == BBDcErrFork)
         sem_post(BBDcd.pMlogSem);
      }

   /* Was it the input process? */
   while (BBDcd.InpProc) {
      rc = waitpid(BBDcd.InpProc, &status, WNOHANG);
      if (rc == 0) break;
      if (rc == -1 && errno == EINTR) continue;
      BBDcd.InpProc = 0;
      if (WIFEXITED(status))
         BBDcd.Minprc = WEXITSTATUS(status);
      else
         BBDcd.Minprc = 102;
      if (BBDcd.Minprc == BBDcErrFork)
         sem_post(BBDcd.pMinpSem);
      }

   } /* End bbdcchldsig() */


/*=====================================================================*
*                         bbdcinit, bbdciniv                           *
*=====================================================================*/

/* Having this extra entry point is a device to enable old versions
*  of clients to use bbdcinit with the original four arguments.  */

int bbdciniv(char *phost, ui32 port, char *pctrl, char *plog,
      int who) {

   BBDcd.Vclients = who;
   return bbdcinit(phost, port, pctrl, plog);

   } /* End bbdciniv() */


int bbdcinit(char *phost, ui32 port, char *pctrl, char *plog) {

   struct sockaddr_in cnsserv;
   struct sigaction childchk;
   struct hostent *hp, *gethostbyname();
   char   *tchnm,*tshnm;         /* Temps for client, server IPs */
   size_t lnm;                   /* Length of a name */
   int    log,CNSin,minplog;     /* File descriptors */
   int    lchnm;                 /* Lengths of chnm, shnm */
   int    retver;                /* Options argument */

/* If ppfeff has already been set, bbdcinit was called twice */

   if (BBDcd.ppfeff)
      abexitm(BBDcErrExsi, "bbdcinit called > once");

/* Before doing anything else, be sure we have permission to
*  write to the log file and to read the control file.  */

   log = 0;
   if (plog) {
#ifdef _ISOC99_SOURCE
      if ((log = open(plog, O_WRONLY|O_CREAT|O_TRUNC,
            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) < 0)
#else
      if ((log = open(plog, O_WRONLY|O_CREAT|O_TRUNC,
            S_IREAD|S_IWRITE|S_IRGRP|S_IROTH)) < 0)
#endif
         abexitme(BBDcErrLogFile, "Could not open log file "
            "for writing");
      }

   CNSin = 0;
   if ((CNSin = open(pctrl, O_RDONLY)) <= 0)
      abexitme(BBDcErrControl, "Could not open CNS input file");

/* Clear out the common data JIC and initialize linked lists */

   tchnm  = BBDcd.exsi;          /* Maybe stored by bbdcexsi */
   retver = BBDcd.Vclients;      /* Maybe stored by bbdciniv */
   memset((char *)&BBDcd, 0, sizeof(struct BBDComData));
   BBDcd.exsi   = tchnm;
   BBDcd.Vclients = retver & ~NOMINPLOG;
   BBDcd.ppfeff = &BBDcd.pfeff;
   BBDcd.ppfsns = &BBDcd.pfsns;
   BBDcd.ppfttv = &BBDcd.pfttv;
   BBDcd.ppfetv = &BBDcd.pfetv;
   BBDcd.ppfstv = &BBDcd.pfstv;
   BBDcd.ppfval = &BBDcd.pfval;

/* Set up action for child process death */

   childchk.sa_handler = bbdcchldsig;
   sigemptyset(&childchk.sa_mask);
   childchk.sa_flags = SA_NOCLDSTOP;
   if (sigaction(SIGCHLD, &childchk, NULL) < 0)
      abexitme(BBDcErrFork, "Could not install SIGCHLD handler");

/* Tell system to ignore SIGPIPE signals.  This is so socket
*  reads will detect a dead server and give a meaningful error
*  message.  This setting should, according to some documentation,
*  (1) be unnecessary (not in practice), and (2) be inherited by
*  our child processes.  See also Implementation Note above.  */

   signal(SIGPIPE, SIG_IGN);

/* Create semaphores that will be used by bbdcchk to determine that
*  the two child processes are OK.  Checking BBDcd->Minprc is not
*  good enough if main process gets to bbdcchk before child can
*  signal error exit.  */

   if ((BBDcd.pMlogSem = sem_open(MlogSemNm, O_CREAT,
         URW_Mode, 0)) == SEM_FAILED)
      abexitme(BBDcErrSema, "Could not open " MlogSemNm);
   if ((BBDcd.pMinpSem = sem_open(MinpSemNm, O_CREAT,
         URW_Mode, 0)) == SEM_FAILED)
      abexitme(BBDcErrSema, "Could not open " MinpSemNm);

/* Indicate that bbdcminp() has not yet finished, then
*  tell the system to call bbdcquit() whenever exit() is called.  */

   BBDcd.Mlogrc = BBDcd.Minprc = -1;
   atexit(bbdcquit);

/* Create a socket and try to contact CNS.  We'll not use rfallo,
*  etc. here because copying to log runs in a child process and
*  uses select().  */

   if ((BBDcd.Cnssock = socket(PF_INET, SOCK_STREAM, 0)) < 0)
      abexitme(BBDcErrSocket, "Could not create a socket to "
         "invoke CNS");

   cnsserv.sin_family = AF_INET;
   if (!port) port = BBDPortInit;
   cnsserv.sin_port = htons(port);

   /* Deal with host argument.  (This code avoids writing over
   *  the string passed in phost JIC.) */
   if ((tshnm = phost)) {     /* Assignment intended */
      char *semic = strchr(tshnm,';');
      if (semic) {
         tchnm = semic + 1;
         lchnm = strnlen(tchnm, MAX_FQDN_LENGTH);
         lnm = semic - tshnm;
         BBDcd.chnm = mallocv(lchnm+lnm+2, "Host name");
         memcpy(BBDcd.chnm, tchnm, lchnm);
         BBDcd.chnm[lchnm] = '\0';
         BBDcd.shnm = BBDcd.chnm + lchnm + 1;
         }
      else {
         lnm = strlen(tshnm);
         BBDcd.chnm = BBDcd.shnm = mallocv(lnm+1, "Host name");
         }
      memcpy(BBDcd.shnm, tshnm, lnm);
      BBDcd.shnm[lnm] = '\0';
      }
   else {
      tshnm = LocalHostIP;
      lnm = strlen(tshnm);
      BBDcd.chnm = BBDcd.shnm = mallocv(lnm+1, "Host name");
      strncpy(BBDcd.shnm, tshnm, lnm);
      }

   if (!(hp = gethostbyname(BBDcd.shnm)))
      abexitm(BBDcErrConnect, ssprintf(NULL, "Errno %4d looking "
         "up IP addr for host %64s", h_errno, BBDcd.shnm));
   memcpy((char *)&cnsserv.sin_addr, (char *)hp->h_addr,
      hp->h_length);

   if (connect(BBDcd.Cnssock, (struct sockaddr *)&cnsserv,
         sizeof(cnsserv)) < 0)
      abexitme(BBDcErrConnect, "Could not open a connection "
         "to CNS server");

/* Apparently, we got a connection, so fork a process to
*  maintain the log.  */

   if ((BBDcd.LogProc = fork()) < 0)
      abexitme(BBDcErrFork, "Could not fork a process to "
         "maintain the CNS log");
   if (!BBDcd.LogProc) {
      /* In child process, execute bbdcmlog */
      char *logargv[4];
      char asck[LMxClSPAA],alog[LMxClSPAA];
      logargv[0] = "bbdcmlog";
      logargv[1] = ssprintf(asck, qMxClSPAfmt "d", BBDcd.Cnssock);
      logargv[2] = ssprintf(alog, qMxClSPAfmt "d", log);
      logargv[3] = NULL;
      execvp(logargv[0], logargv);
      exit(BBDcErrFork);      /* JIC */
      }

/* Open a second socket on the next higher-numbered port and listen
*  for CNS to send confirmation of the configuration.  Note that
*  this socket uses the ROCKS library for buffering and the socket
*  is left pending until the BBD calls bbdcchk, thus allowing the
*  BBD to continue setup in parallel with CNS setup until the two
*  processes finally must liaison.  */

   BBDcd.DataPort = port + 1;
   BBDcd.ndrecv = rfallo(NULL, READ, TEXT, LISTENER, TOP,
      NO_LOOKAHEAD, REWIND, RELEASE_BUFF, IGNORE, IGNORE,
      BBDcd.DataPort, ABORT);

/* Open a file for bbdcminp logging (this can be turned off if
*  necessary by setting the NOMINPLOG bit in the retver argument). */
   minplog = 0;
   if (!(retver & NOMINPLOG)) {
#ifdef _ISOC99_SOURCE
      if ((minplog = open(MINP_ERR_FILE, O_WRONLY|O_CREAT|O_TRUNC,
            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) < 0)
#else
      if ((minplog = open(plog, O_WRONLY|O_CREAT|O_TRUNC,
            S_IREAD|S_IWRITE|S_IRGRP|S_IROTH)) < 0)
#endif
         abexitme(BBDcErrLogFile, "Could not open bbdcminp log file "
            "for writing");
      }

/* Now it is safe to fork another process to send the input file
*  to CNS.  This allows this main process to go ahead with the
*  game while CNS sets up (possibly in a different computer).
*  This also allows for possible future development in which the
*  client can actually interrupt CNS, send CHANGE cards, and restart.
*/

   if ((BBDcd.InpProc = fork()) < 0)
      abexitme(BBDcErrFork, "Could not fork a process to "
         "communicate neural data with CNS");
   if (!BBDcd.InpProc) {
      char *inpargv[8];
      char asock[2*LMxClSPAA],ainp[LMxClSPAA];
      char avcl[LMxClSPAA],aport[LMxClSPAA];
      inpargv[0] = "bbdcminp";
      if (minplog > 0)
         ssprintf(asock, qMxClSPAfmt "d " qMxClSPAfmt "d",
            BBDcd.Cnssock, minplog);
      else
         ssprintf(asock, qMxClSPAfmt "d", BBDcd.Cnssock);
      inpargv[1] = asock;
      inpargv[2] = ssprintf(ainp,  qMxClSPAfmt "d", CNSin);
      inpargv[3] = BBDcd.chnm;
      inpargv[4] = ssprintf(avcl,  qMxClSPAfmt "d", BBDcd.Vclients);
      inpargv[5] = ssprintf(aport, qMxClSPAfmt "d", BBDcd.DataPort);
      /* If no exsi info, argv[6] becomes NULL and ends the chain */
      inpargv[6] = BBDcd.exsi;
      inpargv[7] = NULL;
      execvp(inpargv[0], inpargv);
      exit(BBDcErrFork);      /* JIC */
      }

/* Return so the BBD can continue setting up.  When it is ready
*  to go, it must call bbdcchk() to match configurations with
*  CNS and prepare to exchange "neuronal" data.  */

#if 0    /*** DEBUG ***/
   mexPrintf("At exit from bbdcinit, LogProc = %d, InpProc = %d, "
      "Minprc = %d, Mlogrc = %d\n", (int)BBDcd->LogProc,
      (int)BBDcd->InpProc, BBDcd->Minprc, BBDcd->Mlogrc);
#endif   /*** ENDDEBUG ***/

   return 0;
   } /* End bbdcinit() */

