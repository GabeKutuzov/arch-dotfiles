Specification for NXDR converter:

Ver 2, 10/23/92, ABP
Rev,   10/03/96, GNR

(NXDR = NSI eXternal Data Representation, as in SunOS XDR(3N) ).


Synopsis:  nxdr -f file [file...] -b object [object...] -c cmd  [-o outfile]
                [-h header file]

Purpose:

nxdr takes a list of header files and a list of object types and generates
a set of conversion tables for those types.  These tables are useful, for
example, to control a byte-swapping routine used in message-passing.

Arguments:

-f file [file...] --  A list of header files that contain the definitions for
                      all objects.  If a dependency between files exists, 
                      order the list from left to right, as if this was the
                      top to bottom order in a C file.

-b object [object...] -- A list of objects, each being a type to be converted.
                      "object" is either one or two words.  If the first word
                      is "struct" or "union" then the second word is inter-
                      preted as the name of a C struct type.  Otherwise, the
                      first word alone is the name (built-in or typedef name).

-c cmd --             The command line used for compiling the current 
                      application, including all compiler flags and macro
                      definitions.  The command line must be enclosed in
                      double quotes.

[-o outfile] --       An optional file name (including path) for the .c file
                      generated by the program.  If the last two characters
                      in the file name are not ".c" then these two characters
                      will be appended to the end of the name.
                      The default output file name is "./nxdrtab.c".

[-h header file] --   An optional file name (including path) for the .h file
                      generated by the program.  If the last two characters
                      in the file name are not ".h" then these two characters
                      will be appended to the end of the name.
                      The default header file name is "./nxdrdef.h"

[-d dependency file] --This option is obsolete but has been retained for
                      compatibility with previous versions.  A value must
                      be entered following '-d' but this value is ignored.

Description:
-------------
nxdr creates a temporary file by concatenating all input files in the order
they are given.  The C preprocessor is invoked for that file, using all flags
from the "cmd" argument, to assure that proper "-D" definitions are in effect.
The preprocessor output is piped to another temporary file.  This file is
then scanned according to the object list and the rules described later,
to produce a set of conversion tables described later.   The tables
are written to the output file, and their prototypes are written into
the header file.

Usage:
-----
Several steps are involved in incorporation of nxdr into an
application:

-- Edit the application's makefile, according to the items below.
Note that if the makefile uses different compiler commands to
generate different executables from the same source code, (e.g.
cns phase 1 and phase2), than each variant should be considered
separately, with different nxdr files for each one.  The remainder
of this section refers to one such 'application'.

   1. Start with a list of the objects that are to be translated.

   2. Make a list of the header files containing those objects.

   3. From the application's makefile, locate the command used
   for compiling the source (and thus the .h) files.

   4. Pick names for the 2 files generated by nxdr.  As an example,
   we'll assume that the default names are used:

   nxdrtab.c -- the generated tables, must reside with the rest of
                the application's source files.
   nxdrdef.h -- the generated prototypes, must reside with the rest
                of the application's header files.

   5. Add the file 'nxdrtab.c' to the list of source files that make
   up the application.

   6. Add the following lines to the makefile:

   nxdrtab.c:   <path and name of nxdr utility>
   	/home/nsi/bin/nxdr <list of arguments>

   Note that the indentation in the last line must be a tab, not blanks.

-- Create a type definition for 'unicvtf', the union conversion
   function type.  This definition must be in some header file that
   will be included in every place that includes 'nxdrdef.h', above
   it.

-- Edit all source files that use nxdr, to include these two header 
   files.

Object rules:
-------------
Objects may be one of the following:

1. Names of any C predefined scalar types (e.g. int, float).
2. Names of any previously defined types, scalar or complex. (Created
   with a typedef statement).
3. Named structure types (e.g. "struct cellblk").
4. Named union types (e.g. "union uunm").

The following restrictions apply:

1. Objects of type (4) must be converted by the programmer.  The utility
   will create a "trap" table which will cause the table interpreter to
   fault.   The programmer must supply a proper routine or table to
   convert such objects.   More discussion of this follows.

2. Nested definitions of named structures and unions are not allowed,
   although ANSI-C does allow them, and extends their scope outside
   the block in which they are declared.

3. All fields within structure objects, which are unnamed unions, must be 
   converted by the programmer.  As in (1.) above, a trap table is 
   generated, to assure that the proper code has been inserted prior
   to running the interpreter.

4. "typedef" statements for structures cannot be combined with the
   declaration of the structure name, although ANSI-C allows it.
   Such a statement should be broken to two, with the struct
   defined in the first statememnt and the "typedef" in the second.

The above rules may seem restrictive, but they are actually in agreement with
general programming conventions, and are meant to simplify the conversion
process with little sacrifice by the programmer.   There are two cases that
may often require some attention -- nested definitions and typedef'ed
structures.  The following examples should clarify these:

1. consider the following code:

struct mainstruct {
   int i,j;
   struct innerstruct {
      char *line;
      int  len;
      } txt;
   float date;
   }

struct innerstruct firsttxt;

The named structure "struct innerstruct" is defined inside another structure.
C allows this, and the definition is later used to instantiate the variable
firsttxt in the example above.  Such a nested definition would add a fair 
amount of complexity to nxdr, and since it may be also considered untraditional
programming, it is prohibited.   The above code should be rewritten as:

struct innerstruct {
   char *line;
   int len;
   };

struct mainstruct {
   int i,j;
   struct innerstruct txt;
   }

struct innerstruct firsttxt;


Note, that no restriction is applied to unnamed structs, and the following
code is legal:

struct anotherstruct {
   float f,g,h;
   struct {
      char ch;
      short l;
      } onechar;
   }

(The difference between the two scenarios is that in the second case, nxdr
 will not have to deal with the inner structure elsewhere in the program.
 In short, nxdr has an important underlying principle, that any named type
 is assumed to have been defined before use.  This is assured in most cases
 by the C compiler, with two exceptions:  the nested structure definition 
 discussed here, and the built-in C scalar types, which must be converted
 by the programmer.)

2. Another example:

typedef struct {
   ...
   ...
   } mystruct;


Such code presents a problem, as the fields of the structure must be
scanned and saved before the type name "mystruct" is encountered. 
This would require scanning the whole input file, and would slow nxdr
considerably.   The code above should be re-written as:

struct mm {
  ...
  ...
  };

typedef struct mm mystruct;


Output of nxdr:
---------------
nxdr generates a C file containing declarations and initializers for
a series of conversion tables.  Each conversion table corresponds to
an object from the list specified by the '-b' command line option or
to a built-in C scalar type.  Each table comprises an array of long
word entries and each of these entries describes an array of fields
of the same type within the object.
  
The name of each array is derived from the type name, according
to the following rules:

Type name                Array name        Example
- - - - - - - - - - - - - - - - - - - - - - - - - -
unsigned                 NXuns_int         NXuns_int
unsigned <tname>         NXuns_<tname>     NXuns_short
signed                   NXint             NXint
signed <tname>           NX<tname>         NXchar
<tname>                  NX<tname>         NXbyte
struct <sname>           NXstr_<sname>     NXstr_CON
union  <uname>           NXuni_<uname>     NXuni_datcol

The first long in each table is the size of the longest simple
member in that table.  Following it, all longs are table entries.
Each entry is expressed as either one or two longs, derived in
the following manner:

- The first long is the expression: (count<<8 | type), where 'type'
  is a one-letter code denoting a basic type (see below), and 'count'
  is the number of consecutive items of that type in the object.

- The second long exists only if the 'type' encoded in the first
  long is one of: 'S', 'J', 'X'
  If type=='S', then the second long is the size of the largest member
     of the structured (i.e. struct or union) type.
  If type=='X', then the second long is the address of another conversion
     table to execute.
  If type=='J', then the second long is the address of a custom conversion
     routine, used for converting unions.

Each table is terminated with a zero element.

(Note that the definition for the table entry itself is not a legal nxdr
 input definition, something that will have to change if the conversion
 tables themselves are ever going to be sent across machines...)

Scalar and array objects always have a conversion array of size one,
whereas structured objects typically have more (except for the case of
a struct with all fields being of the same type, or scalar types that
map to the same type).

The meanings of the various type codes are as follows:

        'D'    -   Double 64 bits (IEEE)
        'F'    -   Float  32 bits (IEEE)
        'P'    -   Pointer 32 bits
        'C'    -   Character 8 bits
        'B'    -   Unsigned character 8 bits
        'H'    -   Integer 16 bits
        'M'    -   Unsigned integer 16 bits
        'I'    -   Integer 32 bits
        'U'    -   Unsigned integer 32 bits
        'L'    -   Integer 64 bits
        'W'    -   Unsigned integer 64 bits
        'V'    -   Void

        'S'    -   Structured type.  Put at the start of
                   any struct or union.
        'T'    -   Trap code. Used with unions, see
                   discussion below.
        'X'    -   Execute another table, pointed to by the
                   second field.  To convert the current field,
                   call the interpreter with that table as its
                   argument, 'count' times.
        'J'    -   Jump to another conversion routine, pointed
                   to by the second field.  Used with unions,
                   see below.

        '\0'   -   Signals "end of array".

        The code 'J' is never generated by nxdr, but rather inserted
        manually by the programmer - see discussion of unions.


Examples: (taken from an actual nxdr output file for CNS):

long NXint[] = {  4,
   ( 1<<8 | 'U' ),
   0 };

This is the table for the type "integer".  An integer is 4 bytes
long on this machine.  Since the type is one of the built-in types,
the table contains only one element, which specifies "convert an
integer, one time".


long NXbyte[] = {  1,
   ( 1<<8 | 'B' ),
   0 };

This is the table for the type "byte".  Although this is not a
built in C type, it maps directly to one, and its table is 
a copy of the table for that type ("unsigned char").


long NXstr_CLSTAT[] = {  4,
   (   1<<8 | 'S'), 4,
   ( 127<<8 | 'I'),
   0 };

This is the table for the type "struct CLSTAT".  This is a
structure whose fields are all longs or arrays of longs,
and the resulting table reads "convert an integer 127 times".


long NXstr_RPDEF[] = {  4,
   (  1<<8 | 'S'), 4,
   ( 17<<8 | 'P'),
   (  6<<8 | 'F'),
   ( 15<<8 | 'I'),
   (  2<<8 | 'U'),
   ( 16<<8 | 'I'),
   (  2<<8 | 'M'),
   (116<<8 | 'H'),
   ( 48<<8 | 'X'), (long)NXstr_DET_SELECT,
   (322<<8 | 'C'),
   (  4<<8 | 'B'),
   (  5<<8 | 'C'),
   (  1<<8 | 'B'),
   0 };

This is the table for the type "struct RPDEF".  Note the
line with code 'X' which reads: "Convert according to table
NXstr_DET_SELECT 48 times".


Handling of unions:
------------------
Unions may appear in two scenarios:  As named unions which are part
of the object list given to nxdr with the -b command line option,
or as unnamed unions inside other structured types.

In either case, the conversion of a union requires knowledge about
its current "state", i.e. which of its appearances is currently
valid.   The strategy for dealing with this is as follows:
- nxdr scans the union, and defines new types for each of the
appearances, which are created by concatanating all names that lead
to the union's name (nested objects), and the string _x, where x
is a counter for each appearance, starting with zero.  Look at 
nxdr output, to make this clearer.
- nxdr creates a prototype for a hand-written conversion routine
for the union.  The interface to that routine is discussed later,
but it is important to mention that the args to it include the
address of the object enclosing the union, so that the routine 
can check various fields to decide about the correct conversion.
- The routine will decide on an appearance, and call the general
conversion routine (nxdrmv() ) with the address of the correct
table, of the _x family.

Example:

The structure JNTDEF in CNS contains a field 'u', which is a union.
This is the output produced by nxdr:

long NXstr_JNTDEF_u_0[] = {   4,
(/*count=*/  1 <<8 | 'S'), 4
(/*count=*/  7 <<8 | 'F'),
(/*count=*/  1 <<8 | 'I'),
(/*count=*/  1 <<8 | 'F'),
   0 };

long NXstr_JNTDEF_u_1[] = {   4,
(/*count=*/  1 <<8 | 'S'), 4
(/*count=*/  7 <<8 | 'F'),
(/*count=*/  4 <<8 | 'I'),
   0 };

long NXstr_JNTDEF_u_2[] = {   4,
(/*count=*/  1 <<8 | 'S'), 4
(/*count=*/  2 <<8 | 'F'),
(/*count=*/  4 <<8 | 'I'),
   0 };

long NXstr_JNTDEF[] = {   4,
(/*count=*/  2 <<8 | 'S'), 4
(/*count=*/  1 <<8 | 'J'),(long)NXFstr_JNTDEF_u,
(/*count=*/  2 <<8 | 'F'),
(/*count=*/  1 <<8 | 'X'),(long)NXstr_CHANGES,
   0 };

The types str_JNTDEF_u_x, where x goes from 0 to 2, are created,
and the programmer, who will have to hand-write the function
NXFstr_JNTDEF_u(), can call nxdrmv() with the proper one.  

The exact interface (set of arguments and return values) for the
union conversion routines is left to the application, which must
define it as type 'unicvtf'.   This is not clean, but came up
since there was no good way to separate nxdr from hybrid 
communications.

Conversion function
-------------------

For the same reason (interleaving of nxdr and communications), the
conversion function is not defined here, but left for the application.
The function nxdrmv(), not in use currently, is the "pure" nxdr
conversion routine.   See description in nxdrmv.c .
