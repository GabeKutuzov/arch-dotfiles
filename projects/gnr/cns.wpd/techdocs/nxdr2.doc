Specification for NXDR2 converter:

V1A, 10/23/92, ABP
Rev, 10/03/96, GNR
V2A, 09/12/99, GNR

(NXDR = NSI eXternal Data Representation, as in SunOS XDR(3N)).

Synopsis: nxdr2 -f incfile -b objfile -c cmd [-o outfile] [-h hdrfile]

Purpose:
-------
nxdr2 takes a list of header files and a list of object types and
generates a set of conversion tables for those types.  These tables
are used by the shared-memory system (membcst(), etc.)  and by the
message-passing library (nncom(), etc.).  The name nxdr2 is used so
version 2 can coexist with version 1, which has a different set of
inputs and outputs.

Why the new version:
-------------------
nxdr2 allows the application to deal with offsets to conversion tables
rather than with pointers to conversion tables.  These offsets can be
sent between processors with different address spaces, allowing the
memory management routines to provide automated data tree traversal.
Additionally, lengths of all types are not determined in nxdr2, but
are output as "sizeof" operators so the .c file produced by nxdr2 can
be compiled on different systems than that on which nxdr2 was run and
still give correct tables.  Last but not least, the new version allows
nested struct and union definitions, even within a typedef, and recog-
nizes "enum" as a base type equivalent to "int" (may require casting
in routines that use the tables generated by nxdr2).  There are no
restrictions on the lengths of identifiers that can be processed.
nxdr2 is designed to be able to handle any valid C program.

Arguments:
---------
-f incfile --         "incfile" is the name of a file containing a
                      list of "#include" directives for all the header
                      files that contain definitions of objects listed
                      in the -b option.  If a dependency between files
                      exists, place the file containing the definition
                      of each object earlier in the list than any file
                      in which that object is used in another defini-
                      tion.  This list has been moved from the command
                      line to a file to facilitate the specification of
                      dependencies in make files. (With some compilers,
                      e.g. acc, it may be necessary for incfile to have
                      a .c suffix.)

-b objfile --         "objfile" is the name of a file containing a
                      list of the objects for which conversion tables
                      are to be generated.  One or more objects may be
                      named on each line, separated by whitespace.
                      Each object name consists of either one or two
                      words.  If the first word is "struct", "union",
                      or "enum", then the second word is interpreted
                      as the name of a C struct, union, or enum type.
                      Otherwise, the first word alone is the name
                      (typedef name).  Unlike with the original nxdr,
                      the order of the list is immaterial.  It is not
                      necessary to list built-in C type names (int,
                      long, float, etc.) or tag or typedef names that
                      are referred to inside a structured type but
                      which do not required their own named table.
                      This list has been moved from the command line
                      to a file to facilitate the specification of
                      dependencies in make files.

-c cmd --             The command line used for compiling the current
                      application, including all -I include directories
                      and -D macro definitions.  The command line must
                      be enclosed in double quotes.

[-o outfile] --       An optional file name (including path) for the
                      .c file generated by the program.  If the last
                      two characters in the file name are not ".c"
                      then these two characters will be appended to
                      the end of the name.  The default output file
                      name is "./nxdrtab.c".

[-h header file] --   An optional file name (including path) for the
                      .h file generated by the program.  If the last
                      two characters in the file name are not ".h"
                      then these two characters will be appended to
                      the end of the name.  The default header file
                      name is "./nxdrdef.h"


Description:
-----------
nxdr2 invokes the C preprocessor on the specified incfile, using all
flags from the "cmd" argument to assure that proper "-D" definitions
are in effect.  The preprocessor output is then scanned according to
the object list and the rules described later to produce a conversion
table described later.  The table is written to the output .c file,
and #defines to locate the various table elements are written to the
output .h header file.  Externs to locate the actual tables must be
placed by the user where needed (typically only in nncom and membcst).

Usage:
-----
Several steps are involved in incorporation of nxdr2 into an
application:

-- Edit the application's makefile according to the items below.
Note that if the makefile uses different compiler commands to generate
different executables from the same source code, then each variant
should be considered separately, with different nxdr files for each
one.  The remainder of this section refers to one such 'application'.

   1. Start with a list of the objects that are to be translated.
      Make an "objfile" containing a list of all these objects.

   2. Make an "incfile" that contains "#include" directives for all
      the header files needed to define those objects--system and
      user-defined header files should be included.

   3. From the application's makefile, locate the command used
      for compiling the source files.

   4. Pick names for the 2 files generated by nxdr.  As an example,
      we'll assume that the default names are used:

   nxdrtab.c -- the generated table, must reside with the rest of
                the application's source files.
   nxdrdef.h -- the generated defines, must reside with the rest
                of the application's header files.

   5. Add the files 'nxdrdef.h' and 'nxdrtab.c' to the list of
      source files that make up the application.

   6. Add the following lines to the makefile:

   nxdrdef.h nxdrtab.c:   <path and name of nxdr2> incfile objfile \
                <all the .h files included in incfile>
   	nxdr2 <list of arguments>

   Note that the indentation in the last line must be a tab, not
   blanks.  If the make utility on your system has a means of analyzing
   header dependencies automatically, the list of .h files in the above
   rule can be omitted.

-- Write type conversion routines for all the unions in the application.
   Give them the names assigned by nxdr2, as defined below, and make the
   arguments conform to the prototype defined by the typedef 'unicvtf'
   in nsitools.h.

-- Edit all source files that allocate, reallocate, or free shared
   memory or that send messages between nodes to use the new functions
   and conversion table definitions.

Object rules:
------------
Objects may be any of the following:

1. Names of C predefined scalar types (e.g. int, float)--these
   are included automatically in any event and are not required.
2. Named structure types (e.g. "struct cellblk").
3. Named union types (e.g. "union uunm").
4. Named enum types (e.g. "enum cases").
5. Names created with a "typedef" statement.

The following restrictions apply:

1. The programmer must supply routines to convert all unions that are
   named in the -b file or that are contained within objects named in
   the -b file.  All such unions must have tag or typedef names so the
   "sizeof" operator can be applied to find their size.  nxdr2 will
   create a "jump" entry in the conversion table which will cause the
   table interpreter to call a routine with a name generated from the
   name of the union.  More discussion of this follows.

2. Function definitions cannot be translated.  Pointers to functions
   included in typedefs or structured data types will be processed
   and coded as pointers in the conversion tables produced by nxdr2.
   However, membcst() and nncom() will not be able to translate
   function pointers to point to the correct function on the receiving
   processor.

3. Conditional compilation that would change the length or number and
   type of elements within a data structure on different processors
   must be avoided.  This error cannot be detected by nxdr2.

4. (The restrictions in the original nxdr regarding identifier lengths
   and nested struct or union definitions have been removed.)

Output of nxdr2:
---------------
nxdr2 generates a .c file containing a global conversion table named
'NXDRTT'.  There is an entry in this table for each object listed in
the file specified by the '-b' command line option and for nonunique
anonymous objects contained within these objects.  Each table entry
comprises an array of long word entries and each of these entries
describes an array of fields of a single type within the object. The
table entries do not have individual names--they are accessed using
the offsets given as "#defines" in the output .h file.

The .c file also contains a table of pointers to the union conversion
routines that the user must write (if any).  This table is named
'NXDRUT'.
  
The offset to each table entry is defined in the .h output file as
the actual offset + 0x80000000L; positive values are used by the
allocp* family of routines as block sizes for unstructured data.
The names assigned to the table offsets in the .h output file are
derived according to the following rules:

Type name          Offset name       Example
-------------------------------------------------
<typedefname>      IX<typedefname>   IXcomplex
enum <ename>       IXenu_<ename>     IXenu_days
struct <sname>     IXstr_<sname>     IXstr_celldata
union  <uname>     IXuni_<uname>     IXuni_datcol

The first long in each table entry is the full size of the data in an
object of that type, obtained using the 'sizeof' operator.  (This is
used by the shared memory allocation routines to determine the size
needed to allocate an array of objects of the that type.)  Following
the size are table entries that comprise either one or two longs,
derived in the following manner:

- The first long is the expression (count<<8 | type), where 'type'
  is a one-letter code denoting a basic type (see below), and 'count'
  is the number of consecutive items of that type in the object.

- If the type is a compound type, a word is generated in the above
  format with type = 'S' and count = size of largest member of the
  type.  This information is used to align the object correctly
  (ignored if ALIGN_TYPE is 0 when the application is compiled).

- The second long exists only if the 'type' encoded in the first
  long is one of 'J', or 'X'.

  If type=='X', then the second long is the word offset of another 
     conversion table to execute.
  If type=='J', then the second long is the expression (ut<<8)|sz,
     where 'ut' is the index of a pointer to a custom union conversion
     routine in the NXDRUT table and 'sz' is the size of the largest
     individual variable in the union, used for alignment.

All the entries but the last in each table use lower-case letters to
indicate that more entries follow.  The type code in the last entry
is an upper-case letter.

Scalar and array objects of base types always have a conversion array
of size one, whereas structured objects typically have more (except
for the case of a struct with all fields being of the same type).

The meanings of the various type codes are as follows (the lengths
given here are the lengths of the items in files and messages, not
necessarily their lengths on the host where the program runs.  Note
that relative to the original nxdr, codes 'E', 'K', 'N', and 'Y'
have been added and the meaning of codes 'S' and 'W' has changed.
Types 'B', 'W', and 'Y' are coded as base types even though they
may be defined by typedefs ('byte', 'si64', and 'ui64', respectively,
in sysdef.h or other header files):

    'B'    -   Unsigned character, 8 bits.
    'C'    -   Character, 8 bits.
    'D'    -   Double, 64 bits.
    'E'    -   Enum, 32 bits.
    'F'    -   Float, 32 bits.
    'H'    -   Integer, 16 bits.
    'I'    -   Integer, 32 bits.
    'J'    -   Jump to another conversion routine to handle a union.
               The next word gives the size of the largest individual
               variable in the union plus the index of a pointer to
               this routine in the NXDRUT table, shifted left 8 bits.
    'K'    -   Jump to another conversion routine to handle a union.
               This entry is followed by two words.  The first gives
               the size of the largest variable in the union and the
               second is a direct pointer to the conversion routine.
               This pointer may have the length of one or two longs.
               Code 'K' is for use in hand-coded conversion tables
               and is never generated by nxdr2.
    'L'    -   Long integer, 32 bits.
    'M'    -   Unsigned integer, 16 bits.
    'N'    -   Unsigned long integer, 32 bits.
    'P'    -   Pointer, MAX_PTR_LENGTH = size of intptr type
               defined in mempools.h.
    'S'    -   Compound type.  The count is always one and the count
               field instead encodes the alignment boundary.  Put at
               the start of the table for any struct or union that
               contains data of more than one base type.
    'U'    -   Unsigned integer, 32 bits.
    'V'    -   Void - taken to be same as pointer.
    'W'    -   Signed long long integer, 64 bits.
    'X'    -   Execute another table, the offset of which is given in
               the next word.  To convert the current field, call the
               interpreter recursively with that table as its argument,
               'count' times.
    'Y'    -   Unsigned long long integer, 64 bits.


Examples (NXDRTT[xxx...] indicates one or more entries beginning at
offset xxx in the NXDRTT table):


NXDRTT[-IXstr_CLSTAT...] =
   sizeof(struct CLSTAT),
   ( 127<<8 | 'L'), ...

This is the table for the type "struct CLSTAT".  This is a
structure whose fields are all longs or arrays of longs,
and the resulting table reads "convert a long 127 times".
The total length of this structure is 508 bytes.


NXDRTT[-IXstr_RPDEF...] = 
   sizeof(struct RPDEF),
   (  sizeof(float)<<8 | 's'),
   ( 17<<8 | 'p'),
   (  6<<8 | 'f'),
   ( 15<<8 | 'i'),
   (  2<<8 | 'u'),
   ( 16<<8 | 'i'),
   (  2<<8 | 'm'),
   (116<<8 | 'h'),
   ( 48<<8 | 'x'), -IXstr_DET_SELECT,
   (322<<8 | 'c'),
   (  4<<8 | 'b'),
   (  5<<8 | 'c'),
   (  1<<8 | 'B'), ...

This is the table for the type "struct RPDEF".  Note the line with
code 'x' which means:  "Convert 48 times according to table at
-IXstr_DET_SELECT".  When space for this structure is allocated, the
memory management routines will use the "sizeof(float)" entry (the
size of the largest element in the struct) to align the structure if
alignment is required on the host where the program is running,
otherwise this information will be ignored.

Handling of unions:
------------------
The conversion of a union requires knowledge of its current "state",
i.e.  which of its appearances is currently valid.  The strategy for
dealing with this is as follows:

--nxdr2 creates a type and a conversion table entry for each of the
appearances.  These types are named by concatenating the name of the
union with the string _x, where x is a counter for each appearance,
starting with _1.

--nxdr2 creates a prototype for a hand-written conversion routine for
the union.  The interface to all union conversion routines is defined
by the typedef 'unicvtf' in nsitools.h.  Please note that you cannot
use a typedef type in a function definition, so the actual code for
the function must not explicitly mention the unicvtf type, but must
just declare the same arguments as given in the unicvtf definition.
These arguments include a pointer to the object enclosing the union,
so the conversion routine can check relevant fields to decide about
the correct conversion.  The conversion routine can also make use of
global variables or data in structures pointed to from within the
parent structure to determine the state of the union.  It is also
permissible for the union conversion routine running on the host to
send information to its counterparts running on comp nodes by using
nnput()/nnget() calls via the broadcast stream passed in the first
argument to the unicvtf routine.

--The conversion routine will decide on an appearance and either
perform the conversion directly or recursively call the conversion
routine that called it (e.g. nncom()) with the offset of the correct
table of the _x family.

Example:

The union exun contains three instances defined as follows:

union exun {
   struct {
      float f1a[7];
      int i1;
      float f1b;
      } exun1;
   struct {
      float f2a[7];
      int i2[4];
      } exun2;
   struct {
      int i3[4];
      } exun3;
   }

This is the output produced by nxdr2:

At NXDRTT[-IXuni_exun_1...]:
   sizeof(union exun),
   (  sizeof(float)<<8 | 's'),
   (  7 <<8 | 'f'),
   (  1 <<8 | 'i'),
   (  1 <<8 | 'F'), ...

At NXDRTT[-IXuni_exun_2...]:
   sizeof(union exun),
   (  sizeof(float)<<8 | 's'),
   (  7 <<8 | 'f'),
   (  4 <<8 | 'I'), ...

At NXDRTT[-IXuni_exun_3...]:
   sizeof(union exun),
   (  4 <<8 | 'I'), ...

At NXDRTT[-IXuni_exun...]:
   sizeof(union exun),
   (  sizeof(float)<<8 | 's'),
   (  1 <<8 | 'J'), (long)(0), ...

extern unicvtf *NXFuni_exun_u;

unicvtf *NXDRUT[] = {
   NXFuni_exun_u,
   ...
   };

The tables NXDRTT[-IXuni_exun_x], where x goes from 1 to 3, are
created, and the programmer, who will have to hand-write the function
NXFuni_exun_u(), can call nncom() with the proper one.  The length of
each variant of the table is set to the length of the union as a whole,
which is the length of the longest variant, i.e the size needed by the
allocation routines and the size used by nncom() to advance to the next
item after the union.

Conversion function:
-------------------

The function nncom() in the nsitools library combines the functions of
converting a structure to or from message format and sending or receiv-
ing it on a link to/from another node in a processor array.  There is
currently no standard library routine to perform conversion without
message passing.

Temporary files:
--------- -----

While it is running, nxdr2 creates several temporary files in the
current working directory.  At normal termination, these files are
erased.  When an abnormal termination (error exit) occurs, one or
more of the temporary files may be left behind because they may
contain information that is useful for diagnosing the error.  The
files should be erased when no longer needed, or they will be erased
automatically the next time nxdr2 is run in that directory.  The
temporary files are as follows:

DOS Name        UNIX Name     Function
--- ----        ---- ----     --------
$runcpp$.bat    $runcpp$      Runs the C preprocessor
<header>.i      <header>.i    Output of C preprocessor, where
                              <header is name of the -f input
                              file minus any .c or .h tail.
$nxdr$.c        $nxdr$.c      C program generated to evaluate
                              an array dimension expression.
$nxdr$.obj      $nxdr$.o      Output of $nxdr$.c compilation.
$nxdr$.exe      $nxdr$        Executable made from $nxdr$.c.
$nxdr$.t        $nxdr$.t      Ouput from executing above file.
$nxdr$.tt       $nxdr$.tt     Standard output from running cpp
                              or C compiler.

