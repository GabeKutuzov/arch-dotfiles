/* (c) Copyright 2011-2012, The Rockefeller University *11115* */
/* $Id: rkprintf.c 19 2011-02-23 22:56:28Z  $ */
/***********************************************************************
*                  ROCKS Library - C Implementation                    *
*                              RKPRINTF                                *
*    Formatted output for printf(), fprintf(), sprintf() emulation     *
*                                                                      *
*  N.B.  The main program of any program that uses this routine must   *
*  pound-define MAIN and OMIT_ROCKV followed by pound-include rocks.h  *
************************************************************************
*  V1A, 08/06/11, GNR - Modified fmtio() for C lib compat + extras     *
*  ==>, 12/04/11, GNR - Last date before committing to svn repository  *
***********************************************************************/

/*---------------------------------------------------------------------*
*        Usage                                                         *
*---------------------------------------------------------------------*/

/*
   rkprintf() provides facilities for formatted output compatible with
the C library formatted output functions and callable from implementa-
tions of printf(), fprintf(), sprintf().  It includes extra formatting
codes to provide all the features of convrt()/sconvrt(), including
overflow and underflow protection, fixed-point numbers with fractions,
array indexing, indenting, etc.  The idea is to allow programs and
library functions that call [fs]printf() to coexist with programs that
need the extended features provided here. rkprintf() is essentially an
interpreter that generates calls to the low-level ROCKS numeric con-
version routines under control of a pseudo-printf() format specifier.

Usage:
   long rkprintf(void (* outcb)(long lout),
      char *line, size_t llen, const char *fmt, ... )

Arguments:
   'outcb' is a pointer to a callback routine that rkprintf() should
      use to write a line of output beginning at 'line'.  This will
      differ according to what type of output the caller requires.
      The callback argument is:
         lout     Length of the output line (<= llen).
      The remaining data needed by outcb() is stored in NPC.

   'line' is a buffer large enough to hold the output generated by
      rkprintf.  A standard null end-of-string character is inserted
      unless the '%O' format code is specified.

   'llen' is the size of 'line'.  No more than this number of
      characters will be written, including the final '\0'.

   'fmt' is a standard printf()-style format specifier with exten-
      sions as described below.  It is followed by a variable-
      length list of the variables or pointers to the variables or
      arrays to be converted.  Numeric values used with the '*'
      code are passed as integers.  Unlike with fmtio(), there is
      no NULL pointer to terminate the list--termination must be
      implicit in the format specifier.

Return value:
   Number of characters written, not including the trailing '\0'.

Differences:
   There are several major differences in usage between this ROCKS
implementation of [fs]printf() and the standard C library versions,
but it is designed to work as expected in normal applications.  Most
important, additional '%' codes are provided in the format specifier
to permit array indexing and other extensions.  By design, these are
codes that should never occur in traditional [fs]printf() calls.
Because all numeric arguments to fmtio() were pointers, codes could
be used to specify argument lengths and types, avoiding the implicit
conversions to int and double float in the C variable-length argument
list syntax.  To preserve that flexibility here, a special flag code
'&' is used to indicate that the argument is a pointer to a value of
the type required by the size and type conversion codes.  This is
optional when an array address is implied by repetition codes.

   Output widths in standard [fs]printf[] are minimum widths.  Here
they are exact widths, which permits predictable table formatting.
Instead of expanding the width, values that are too large to fit in
the specified width are converted to exponential format.  If there is
not room even for that, the field is filled with asterisks.  However,
if a width specification is omitted, or flag 'nJ' is used, the mini-
mum necessary width will be used, as in the standard versions.

   The largest valid width specification for numeric output is
(RK_MXWD+1) = 32.  The size of the line buffer must be passed as
an argument to rkprintf() to permit overflow checking.  The
definition of sprintf() does not permit checking, but a default
implied length of 255 will be provided in the call to rkprintf().

   Traditional size codes before a conversion character will be
recognized whether or not the '&' flag (see below) is present.
A few additional size codes have been added.  The recognized size
codes are:  'hh' (char), 'h' (short), 'j' (32-bit regardless of
size of int or long on the machine), 'l' (long), 'll' (long long),
'w' (64-bit), and 'z' (size_t).  Size codes L,j,q,Z defined in some
implementations of [fs]printf() are used for other purposes here,
code 't' will result in abexit 180.  Similarly, nonstandard flags
'I' and ''' (single quote) will result in abexit 180.

   Because this program omits the 'E' in exponential-format output,
the code pairs e,E and g,G are the same.  Because a switch to expo-
nential format always occurs when an 'f' format field overflows,
'g' is the same as 'f' except for also invoking underflow control.
Conversion codes D,O,U,X have different definitions in different
versions of the traditional library and are best not used.  For
convenience, 'D' and 'U' are implemented here as synonyms for 'd'
and 'u', and 'x' and 'X' as hexadecimal conversions with lower- or
uppercase 'a' through 'f', respectively, but 'O' is an independent
code to skip the '\0' at the end of string output.  Codes a,A,C,S
will result in abexit 180 ('C' is reserved for future implementation
of complex number output).

   Other items that exist in some implementations of [fs]printf()
that are not implemented here include:  Wide characters, locale
control of decimal character and thousands separator, separate
representations of infinity vs NAN and use of conversion codes
'f' vs 'F' to control case of NAN, 'm$' to indicate that the m'th
argument is to be used, return of number of characters that would
have been written when output field overflow occurs.

   Individual format codes are interpreted as follows.  Case is
significant except for type codes, where either upper or lower case
may be used for types d,e,f,g,i,q,u,x.  Codes beginning with '%' in
the documentation are not associated with numeric conversions and may
appear where needed in the format specifier.  Other codes are used
with numeric conversions.  In square brackets ('[]'), the words
'flag', 'prec', 'size', or 'type' indicate the position in the
standard [fs]printf() format specifier where this code may appear.
'w', 'n', and 'd' indicate numeric parameters which are optional if
enclosed in '[]' in the writeup.  '^' has two uses: Because '0' is
defined as a flag in the standard library, '^' may be used wherever
0 is required as a numeric parameter.  When '^' is used as a flag,
it must be preceded by a nonzero number to disambiguate this usage.

.A [prec] Where a decimal precision would normally be given, 'A'
   indicates automatic decimal placement.
nb [type] Writes 'n' blanks to the output.  [Note 3]
nB [flag] Binary scaling (with I or U). Must be preceded by 'n',
   the number of bits to the right of the binary point (0 <= n < 63).
   'n' may consist of two integers separated by a '/' or '|'.  In the
   first case, the second scale is used if the RK_BSSLASH bit was set
   by a previous call to bscompat().  In the second case, the second
   scale is used if the RK_BSVERTB bit was so set.  The 'B' specifi-
   cation applies only to the immediately following format code.
c  [type] Argument is an integer printed as a single character.
C  [type] Reserved for future use for complex numbers.
[dD]  [type] Convert a fixed-point (integer) value in decimal format.
   The d code may be preceded by a 'w.d' specification.  The decimal
   is normally used only with binary scaling.  [Notes 1,2]
[eE]  [type] Convert a floating point value in exponential format with
   6 decimal places if precision is not specified.  There is no 'e' or
   'E' in the output, unlike with the standard library.  The standard
   library specifies that the argument is (or is coerced to) a double,
   but if a pointer is used, 'je' may be use to specify a pointer to
   a single-precision float.  [Note 1]
[fF]  [type] Convert a floating point value in decimal format with 6
   decimal places if precision is not specified.  If the width of the
   field would be exceeded, e format is used (similar to format 'g'
   in the standard C library).  The standard library specifies that
   the argument is (or is coerced to) a double, but if a pointer is
   used ('&' or 'Z' code), a single-precision float is impled--use
   '[qQ]' for double.  [Note 1]
[gG]  [type] Same as f in this implementation except underflow
   conversion to exponential format is also provided.  [Note 1]
h,hh  [size] Variable is of type short or char, bzw.
   See explanation above.
[iI]  [type] Same as d.  [Notes 1,2]
j  [size]  Variable is a 32-bit fixed point number regardless of
   the size of an int or a long on the machine.  The variable is
   a single-precision floating-point number if this code is used
   with conversion type 'e' or 'E' and a pointer to the argument.
   (In some implementations, 'j' is used for type 'intmax'.)
[n]J  [flag] Left-Justify.  This is an extension of the standard
   [fs]printf() '-' flag.  If a value for 'n' is given, 'n' blanks
   are inserted to the right of the output field--the width of the
   field is data dependent and the width given in the format is
   only a maximum width (which includes the 'n' blanks).  If a
   value for 'n' is not given, enough blanks are inserted to fill
   out the width specified in the format item, if any.
   Overrides the '0' flag if both are given.  [Note 3]
k  [type] A wide random number seed (sysdef.h 'wseed' type) will
   be printed in format '(mm,nn)' where 'mm' and 'nn' are the two
   32 bit components of the seed.  This code may be preceded by a
   'w' width specification.  If the output will not fit in the
   specified space, the field is filled with asterisks.
K  [type] Binary option Keys.  This format requires two arguments
   in the argument list.  The first is an ASCII string specifying
   the codes to be printed for each 1 bit in the second argument,
   which is an unsigned integer or (with '&' code) a pointer to
   the data item to be converted.  Characters other than uppercase
   letters and digits in the code specification indicate bit posi-
   tions in the data that are not encoded in the output. This code
   may be preceded by a 'w' width specification.  The output is
   always left-justified--shorter strings are padded with blanks
   to 'w' characters unless preceded by 'nJ', in which case the
   actual string length is used, followed by 'n' blanks.
   [Notes 1,3]
l,ll  [size] Variable is of type long or long long, bzw.  See
   explanation above.
%[n]L  Lines.  Force a page eject if the next 'n' lines of output
   would not all fit on the current page (default: 1).  [Notes 3,4]
n  [type] Writes the number of characters written so far to the
   next argument, which should be a pointer to the type given by
   the preceding size code (default int).
%N Not-forced.  Sets the RK_NFSUBTTL bit, so the output is inter-
   preted as a subtitle which does not force a new page.  [Note 4]
o  [type] Convert a fixed-point (integer) value in octal format.
   The precision modifier is ignored. Binary or decimal scaling
   is an error.  [Note 1]
%O Overwrite.  Omit putting '\0' at end of the output string
   produced by s[n]printf().  Ignored in other cases.
p  [type] Writes the output as a hexadecimal pointer of what-
   ever is the standard size of a pointer in the implementation.
   A size specification that differs from this is an error.
%[n]P  Priority.  Set the priority of the printed output to 'n'
   (1 <= n <= 5; default: 2).  [Notes 3,4]
[qQ]  [type] "Quality".  Same as 'f' except always implies double
   precision whether or not '&' is given.
n[rR]  [flag] Repeat count used as a flag before a format code.
   The repeat count may be zero to skip the next format code or the
   '?' flag may be used along with a repeat count to skip output.
   If the flag is 'r', there is a separate data item in the argument
   list for each repetition.  If the flag is 'R', the data item is
   presented as a pointer to an array of size 'n'.  [Note 3]
s  [type] String.  The argument is a pointer to a string, which is
   copied to the output.  In accord with the standard specification,
   if a '.d' "precision" is given, no more than 'd' characters are
   copied.  Otherwise the entire string is copied, except a buffer
   overflow is an error.  If a width is given, it is the number of
   characters to be transmitted.  Shorter strings are padded with
   blanks to 'w' characters unless the 's' code is preceded by 'nJ',
   in which case the actual string length is used, followed by 'n'
   blanks, up to a maximum of 'w' characters.  Use the '^' flag to
   indicate the length of the string for indexing purposes if dif-
   ferent.  (Wide characters are not supported at this time.)
%S Subtitle.  Sets the RK_SUBTTL bit, causing the output to be
   treated as a new subtitle.  (If '%N' and '%S' both given, '%N'
   prevails.)  [Note 4]
%nT  Set the record poinTer to column 'n' (counting from 1).  The
   output buffer is not blanked, allowing output from more than one
   call to be combined.  Use 'nb' to blank the buffer if needed.
   When the line is printed, everything up to the current pointer
   is included.  Some output may be lost if the pointer is back-
   spaced.  This feature is useful for making graphs on the printer.
   [Note 3]
[uU]  [type] Convert an unsigned fixed-point value in decimal for-
   mat. The 'u' code may be preceded by a 'w.d' specification. The
   decimal is normally used only with binary scaling.  [Notes 1,2]
V  [flag] If decimal, causes output generated by the following
   format specification to use E format if all precision otherwise
   would be lost.  If hex, causes output to use the number of
   characters implied by the item width. 'v' is currently a synonym
   for 'V', but this usage may change in future versions.
w  [size]  Variable is a 64-bit fixed point number. (This is safer
   than 'll', which may indicate 64 or 128 bits depending on the
   system.  At present, output of 128 bit long longs is not
   supported).
x,X  [type] Hexadecimal output.  In accord with the standard, type
   'x' generates lowercase letters (a-f) for values 10-15, type 'X'
   generates uppercase (A-F).  The precision modifier is ignored.
   Binary or decimal scaling is an error.
%[n]Y  Spout the next 'n' lines of output (n < 256, default: 1).
   [Notes 3,4]
z  [size]  Variable is of type size_t.  See explanation above.
%nZ  Specifies that the next list item is a pointer to an array or
   structure of siZe 'n' items.  The type (or types if a struct)
   are determined by the size and type codes of the following
   format specifiers.  [Note 3]
0  [flag] The value is padded on the left with zeros rather than
   blanks.  If the '0' and '-' flags both appear, '0' is ignored.
~  [flag] If an output is skipped because of a '?' flag or zero
   repeat count with the 'R' flag, blanks are written corresponding
   to the width of the items skipped.
%[n]!  Error message.  Sets iexit to 'n' (1 <= n <= 8, default 1)
   and priority to 1.  [Notes 3,4]
#  [flag] Has as much as possible the same meaning as the '#'
   flag in the standard [fs]printf().  Prefix octal output with
   '0'.  Prefix hexadecimal output with '0x' or '0X' depending on
   whether the type code was 'x' or 'X', bzw.  Always include a
   decimal point for e,f,g,q even if item is an integer.
%% Print a literal '%'.
n^ [flag] Overrides item size of the current format item for use
   in array or string indexing.  This code is useful for indexing
   through an array of structures.  [Note 3]
&  [flag]  This code specifies that the next numeric argument is
   provided as a pointer, not a value.  The type is provided by
   the usual 'size' and 'type' codes.
*  Indicates that an integer argument should be picked up and used
   for the integer value (n,w, or d) expected at that location.
   If both the integer and '*' are missing in the format, a default
   value of 1 is used except where documented otherwise (J,P codes).
-  [flag] The converted value is left-justified on the field bound-
   ary.  The converted value is padded on the right with blanks if
   a minimum width is specified.  See 'J' for an extended version
   of this flag: '-' is equivalent to 'J' with no numeric argument.
+  [flag] A sign (+ or -) is always placed before the result of
   a signed numeric conversion.  By default, a sign is used only
   for negative numbers.  Overrides the ' ' flag if both are given.
' ' (a space)  [flag] A blank is always left before a positive num-
   ber produced by a signed conversion (preventing two adjacent
   numeric values from appearing concatenated in the output.
%n=  Gives the index increment for arrays in <> repeats.  Note
   this counts items, not bytes, unlike the '^' code.  [Note 3]
%| Indent.  Records the current column location.  Following this
   code, when scanning returns to a left parenthesis or bracket on
   a new line, a sufficient number of blanks is inserted to cause
   the output to be indented to the recorded position.  [If this
   code is preceded by a number, it is a binary scale, see 'B'.]
%; Causes interpretation of the format to terminate if there is
   no pending 'Z' array output or '()' or '<>' repetitions.  The
   semicolon may be used to turn off the conversion of following
   literals when the last number in a series has been written.
%[n]\n  Linefeeds.  Write 'n' linefeeds (default 1) to the output.
   [Note 3]
.<n  [prec]  Variant of automatic decimal in which the decimal
   parameter is the lesser of 'n' and the automatic value needed
   to just fit the value in the given width with one leading blank.
   [Note 3]
?  [flag] Conditional output.  An int is read from the argument
   list and printing of variables controlled by this format code
   is skipped if the argument is 0.
%/ Flush.  Flush the line buffer to the output device.  An error
   occurs if used in s[n]printf().  [If this code is preceded by
   a number, it is a binary scale, see 'B'.]
%[n](...%)  Format codes enclosed in parentheses are repeated 'n'
   times.  On each repetition, new argument variables are read
   unless a '%nZ' array length code is in effect.  In that case,
   'n' may be omitted and the format repeats until the 'Z' count
   is satisfied.  Parentheses can not be nested.  [Note 3]
%n<...%>  Format codes enclosed in angle brackets are repeated 'n'
   times.  On each repetition, the same argument variables are
   reused.  Each item is assumed to be an array, which is indexed
   to the next unused element on each iteration of the '<>'.  To
   step through array items referred to by formats with '<>' with
   stride greater than 1, use the '=' flag.  The stride value is
   multiplied by the size of each item (possibly itself modified
   with the '^' flag) and further multiplied by the iteration
   number of the '<>' (minus 1) to obtain the total byte offset
   for that item, i.e. the stride is counted in numbers of items
   independent of the size of each item.

Note 1.  Fixed-point arguments are assumed to be coerced to ints
   and floating-point arguments coerced to doubles unless the code
   '&' has been given or the format specifies an array, in which
   case a pointer must be passed.  Arrays are assumed to be the
   type specified by the size and type codes, without coercion.
Note 2.  Precision with fixed-point arguments in standard [fs]printf()
   gives the minimum number of digits.  Here, it gives the number of
   decimals, as with floating-point conversions.  Padding with zeros
   can be accomplished with the '0' modifier and a specified width.
Note 3.  'n' or 'w' may be replaced by '*' to read an integer value
   from the argument list for this quantity.  Use '^' to code a 0
   numeric parameter.
Note 4.  This code is ignored unless output is written with cryout()
   (printf() call).
*/

/*---------------------------------------------------------------------*
*        Error actions:                                                *
*---------------------------------------------------------------------*/

/*
   Abexit codes in the range 180-199 are allocated to this program.
Because these errors can only be coding errors, no message text is
provided.  For explanation, type 'abend nnn' at the command line,
where 'nnn' is the abexit error number.
*/

/*---------------------------------------------------------------------*
*        Design notes:                                                 *
*---------------------------------------------------------------------*/

/*
   1. When cryout() is used for printf() output, the new RK_PF code
      is used to indicate that line formatting is via ASCII LF and
      not ANSI carriage control characters.  A 'CR' without a 'LF'
      generates a '+' code for overstriking.
*/

/*---------------------------------------------------------------------*
*        Global definitions                                            *
*---------------------------------------------------------------------*/

#include <ctype.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include "sysdef.h"
#include "rkprintf.h"
#include "rkxtra.h"
#include "rkarith.h"

/* Configuration constants to interact with CRK routines */
#define  MxBS       63        /* Maximum binary scale */
#define  MxDec      14        /* Maximum decimals */
#define  MxIex       8        /* Maximum iexit error code */
#define  MxdsMask 0x000f0000  /* Mask for maximum decimal scale */

/* Define defaults */
#define  DFLT_DECIM  6        /* Default decimal spec */
#define  DFLT_IEXIT  1        /* Default iexit */
#define  DFLT_LINES  1        /* Default lines */
#define  DFLT_NEWLN  1        /* Default write newlines */
#define  DFLT_PRTY   2        /* Default priority */
#define  DFLT_SPOUT  1        /* Default spout */

/* Common (state) variables shared with callers who need to
*  set up the va_list to access the arguments  */

struct RKPFC NPC;


/*---------------------------------------------------------------------*
*     digits() - pick up a decimal value from format string            *
*                 or from an integer argument if '*' coded.            *
*                                                                      *
*     Returns FALSE if no digits found, otherwise TRUE.                *
*     Decimal value is in NPC.dig.                                     *
*                                                                      *
*     N.B.  A leading digit '0' will be interpreted as the '0' flag    *
*     for consistency with the standard C library version. '^' may be  *
*     coded to obtain a zero numeric parameter.                        *
*---------------------------------------------------------------------*/

static int digits(void) {

   if (*NPC.fptr == '*') {
      NPC.dig = va_arg(NPC.lptr, int);
      ++NPC.fptr; }
   else if (*NPC.fptr == '0') return FALSE;
   else if (*NPC.fptr == '^') {
      NPC.dig = 0;
      ++NPC.fptr; }
   else {
      register int value;
      if (!isdigit(*NPC.fptr)) return FALSE;
      value = (int)(*NPC.fptr - '0');
      while (isdigit(*(++NPC.fptr)))
         value = 10*value + (int)(*NPC.fptr - '0');
      NPC.dig = value;
      }
   /* This will catch neg list items or numeric overflow */
   if (NPC.dig < 0) abexit(182);
   return TRUE;
   } /* End digits() */


/*---------------------------------------------------------------------*
*     qindent() - apply requested indent when starting new line        *
*---------------------------------------------------------------------*/

static void qindent(void) {

   int indent;                /* Number of columns to indent */
   if ((indent = NPC.line + NPC.icol - NPC.pdat) > 0) {
      /* An indent was stored and we just moved before it */
      memset(NPC.pdat, ' ', indent);
      NPC.pdat += indent;
      }
   } /* End qindent() */


/*---------------------------------------------------------------------*
*     gotlf() - perform end-of-line callback                           *
*                                                                      *
*     Argument:                                                        *
*        nlf      Linefeed count.                                      *
*                                                                      *
*     If nlf < 0, there are one or more LFs in the format.  gotlf()    *
*     copies these to the buffer and counts them, then issues the      *
*     outcb() callback to write the output.  If nlf >= 0, gotlf()      *
*     adds nlf LFs to the buffer, then issues the outcb() callback.    *
*     In all cases, it then resets NPC.pdat for another line.  If in   *
*     subtitle mode, only the final call with nlf == 0 writes output.  *
*        (spout() and tlines() calls and addition of a '\0' to the     *
*     buffer when flushing should be made by the outcb() routine if    *
*     it is calling cryout().)                                         *
*---------------------------------------------------------------------*/

static void gotlf(int nlf) {

   long lout;                 /* Length of output */
   int  ilf;                  /* LF counter */
   int  kout = nlf == 0 ||    /* TRUE if OK to make callback */
      !(NPC.ccode & (RK_SUBTTL|RK_NTSUBTTL|RK_NFSUBTTL));

   if (nlf < 0) do {
      /* NLs in the format */
      for (ilf=0; *NPC.fptr=='\n'; ++ilf) {
         if (NPC.pdat + 1 >= NPC.top) {
            if (kout) break; else abexit(181); }
         *NPC.pdat++ = *NPC.fptr++;
         }
      NPC.totl += ilf;
      lout = NPC.pdat - NPC.line;
      if (kout) {
         NPC.cnln = ilf;
         NPC.outcb(lout);
         NPC.pdat = NPC.line;
         }
      } while (*NPC.fptr == '\n');
   else do {
      /* NLs requested by codes or end of format */
      for (ilf=0; ilf < nlf; ++ilf) {
         if (NPC.pdat + 1 >= NPC.top) {
            if (kout) break; else abexit(181); }
         *NPC.pdat++ = '\n';
         }
      NPC.totl += ilf;
      lout = NPC.pdat - NPC.line;
      if (kout && (lout > 0)) {
         NPC.cnln = ilf;
         NPC.outcb(lout);
         NPC.pdat = NPC.line;
         }
      } while ((nlf -= ilf) > 0);

   } /* End gotlf() */


/*---------------------------------------------------------------------*
*                                                                      *
*     rkprintf() - Interpret a format string, convert data items       *
*                                                                      *
*---------------------------------------------------------------------*/

long rkprintf(void (*outcb)(long lout),
      char *line, size_t llen, const char *fmt, ... ) {

   const char *gptr = fmt;    /* Group pointer */
   const char *bkfp;          /* Bracket backup format pointer */
   void *bkip;                /* Bracket backup item pointer */
   void *iptr;                /* Data item pointer */
   char *kokeys;              /* Ptr to keys for K formats */
   char *wdat;                /* Working data: pdat or tdat */
   ui32 bs;                   /* Binary scale or alt binary scale */
   ui32 code;                 /* bcdin/out conversion code */
   int  bctr = 1;             /* Bracket count */
   int  dec;                  /* Decimal spec */
   int  dim;                  /* Current array dimension */
   int  idim;                 /* Initial array dimension */
   int  grp = 0;              /* Current parens group, negative
                              *  to repeat based on 'dim' count */
   int  incr = 1;             /* Index increment for brackets */
   int  iadv;                 /* Item size override */
   int  itemsize;             /* Size of item */
   int  jfbl;                 /* Blanks after left-justify */
#define  JFULLWID (RK_MXWD+1)    /* Pad to full width */
   int  ndx = 0;              /* Bracket index */
   int  rep;                  /* Repeat count */
   int  width;                /* Field width */
                              /* Kind of conversion */
   enum kconv { kcnone, kcblnks, kcchar, kccmplx, kcfixpt, kcexp,
      kcfloat, kcdbl, kcwseed, kckeys, kcnout, kcptr, kcstring } kcsw;
   byte gotnum;               /* TRUE if numeric format retrieved */
   byte lflags;               /* Flags local to one conversion */
#define  GOTBSSL  0x10           /* Got BSSLASH alternative scale */
#define  GOTBSVB  0x20           /* Got BSVERTB alternative scale */
   char padchar;              /* Pad character */
   char tdat[RK_MXWD+3];      /* Temp for when width is unknown */

/* Initialize the NPC common block */

   RK.numcnv = 0;             /* Count total conversions */
   NPC.fptr = fmt;
   NPC.pdat = NPC.line = line;
   NPC.top = line + llen;     /* End of buffer signal */
   NPC.outcb = outcb;         /* Output call back */
   NPC.totl = 0;
   NPC.icol = 0;
   NPC.ccode = RK_LN0;
   NPC.cprty = RK_P2;
   NPC.pfflgs = NULLTERM;
   dim = idim = 1;            /* Initial array dimension */

RestartAfterConversion:
   NPC.pfflgs &= ~IMMFLGS;       /* Clear one-conversion flags */
   bs = code = 0;                /* Initialize BCD call */
   dec = iadv = jfbl = 0;        /* No decimal, no item size override,
                                 *  no blanks after left-justify */
   rep = 1;                      /* Reset repeat count */
   width = RK_MXWD + 1;          /* Default width */
   lflags = 0;

/*---------------------------------------------------------------------*
*  State 1:  Scan format, transfer characters to output and process    *
*  standalone codes until a conversion code or end-of-format.          *
*---------------------------------------------------------------------*/

   for ( ; *NPC.fptr; ++NPC.fptr) {
      if (*NPC.fptr != '%') {
         if (NPC.pdat >= NPC.top) abexit(181);
         if (*NPC.fptr == '\n') { gotlf(-1); --NPC.fptr; }
         /* Move format char to output */
         else *NPC.pdat++ = *NPC.fptr, ++NPC.totl;
         }
      else {

/*====Two levels of indenting suppressed, here to end of State 1======*/

   ++NPC.fptr;                   /* Skip over the '%' */
   gotnum = (byte)digits();      /* Check for count before code */
   switch (*NPC.fptr) {

   case 'L' :                    /* Reserve lines */
      tlines(gotnum ? NPC.dig : DFLT_LINES);
      continue;

   case 'N' :                    /* Non-forced subtitle */
      if (gotnum) abexit(185);
      NPC.ccode |= RK_NFSUBTTL;
      continue;

   case 'O' :                    /* Omit null terminator */
      if (gotnum) abexit(185);
      NPC.pfflgs &= ~NULLTERM;
      continue;

   case 'P' : {                  /* Priority */
      int ipri = gotnum ? NPC.dig : DFLT_PRTY;
      if (ipri < 1 || ipri > 5) abexit(187);
      NPC.cprty = RK_P1*ipri;
      continue;
      } /* End ipri local scope */

   case 'S' :                    /* Regular subtitle */
      if (gotnum) abexit(185);
      NPC.ccode |= RK_SUBTTL;
      continue;

   case 'T' :                    /* Set column Pointer */
      if (!gotnum) abexit(186);
      NPC.pdat = NPC.line + max(0,NPC.dig-1);
      continue;

   case 'Y' : {                  /* SPOUT */
      int ispt = gotnum ? NPC.dig : DFLT_SPOUT;
      if (ispt >= RK_P1) abexit(187);
      NPC.cspt = ispt;
      continue;
      } /* End ispt local scope */

   case 'Z' :                    /* Array dimension */
      if (dim > 1) abexit(184);  /* Error if in middle of array */
      if (!gotnum) abexit(186);
      idim = dim = NPC.dig;   /* Set initial array dimension */
      NPC.pfflgs |= INDEXING;
      continue;

   case '%' :                    /* Literal '%' */
      if (gotnum) abexit(185);
      if (NPC.pdat >= NPC.top) abexit(181);
      *NPC.pdat++ = *NPC.fptr;
      continue;

   case '!' : {                  /* Set 'iexit' error code */
      int iex = gotnum ? NPC.dig : DFLT_IEXIT;
      if (iex < 1 || iex > MxIex) abexit(187);
      NPC.cprty = RK_P1 + iex*(RK_E1 - RK_P1);
      continue;
      } /* End iex local scope */

   case '=' :                    /* Bracket increment */
      if (!gotnum) abexit(186);
      incr = NPC.dig;
      continue;

   case '|' :                    /* Store indent column */
      if (gotnum) goto FlagState;
      NPC.icol = NPC.pdat - NPC.line;
      continue;

   case ';' :                    /* Conditional stop */
      if (gotnum) abexit(185);
      if (bctr <= 1 && grp <= 1 && !dim) goto EndItAll;
      continue;

   case '\n' :                   /* Write blank lines */
      gotlf(gotnum ? NPC.dig : DFLT_NEWLN);
      continue;

   case '/' :                    /* Write lines, flush output */
      if (gotnum) goto FlagState;
      NPC.ccode |= RK_FLUSH;
      gotlf(0);                     /* Clear output buffer */
      continue;

   case '(' :                    /* Begin format group */
      if (NPC.pfflgs & INBKTS) abexit(191);
      grp = gotnum ? NPC.dig : -1;  /* -1 to use dim count */
      if (grp == 0) abexit(183);    /* Tried to skip altogether */
      NPC.pfflgs |= INPARENS;
      gptr = NPC.fptr;              /* Save format backup address */
      continue;

   case ')' :                    /* End format group */
      if (gotnum) abexit(185);
      if (grp < 0 && !dim) continue;
      if (--grp) {
         qindent();                 /* Indent if requested */
         NPC.fptr = gptr;           /* Return to last '(' */
         } /* End format group, continue scanning */
      else
         NPC.pfflgs &= ~INPARENS;
      continue;

   case '<' :                    /* Begin bracket group */
      if (NPC.pfflgs & INDEXING) abexit(184);
      if (NPC.pfflgs & INPARENS) abexit(191);
      if (!gotnum) abexit(186);
      bctr = NPC.dig;
      if (bctr == 0) abexit(183);   /* Tried to skip altogether */
      NPC.pfflgs |= INBKTS;         /* Items in brackets are ptrs */
      bkfp = NPC.fptr;              /* Save format backup address */
      bkip = iptr;                  /* Save item pointer */
      /* Save argument list location */
      memcpy((char *)&NPC.bklp,(char *)&NPC.lptr,sizeof(NPC.lptr));
      continue;

   case '>' :                    /* End bracket group */
      if (gotnum) abexit(185);
      if (--bctr) {                 /* Still counting */
         qindent();                 /* Indent if requested */
         ndx += incr;               /* Increment index */
         NPC.fptr = bkfp;           /* Backup format */
         iptr = bkip;               /* Backup item pointer */
         /* Back up argument list */
         memcpy((char *)&NPC.lptr,(char *)&NPC.bklp,sizeof(NPC.lptr));
         idim = dim = 1;      /* Reset array dimension */
         } /* End bracket group backup */
      else {                        /* Count exhausted */
         ndx = 0, incr = 1;         /* Restore normal indexing */
         NPC.pfflgs &= ~INBKTS;
         }
      continue;

   default:                      /* Possible numeric conversion */
      goto FlagState;

      } /* End state 1 (standalones) format switch */

/*=====================Resume normal indenting========================*/

   }} /* End else and for *NPC.fptr */

/* End of format scan.  Return to caller.  */

EndItAll:
   NPC.pfflgs |= ENDITALL;
   gotlf(0);
   return NPC.totl;


/*---------------------------------------------------------------------*
*  State 2:  Probable numeric conversion, check for flags.             *
*---------------------------------------------------------------------*/

FlagState:
   while (*NPC.fptr) {

/*=====One level of indenting suppressed, here to end of State 2======*/

   switch (*NPC.fptr) {

   case '|' :                    /* Binary scale RK_BSVERTB choice */
      if (!gotnum) abexit(186);
      bs = (ui32)NPC.dig;
      lflags |= GOTBSVB;
      break;

   case '/' :                    /* Binary scale RK_BSSLASH choice */
      if (!gotnum) abexit(186);
      bs = (ui32)NPC.dig;
      lflags |= GOTBSSL;
      break;

   case 'B' : {                  /* Binary scale */
      if (!gotnum) abexit(186);
      switch (lflags & (GOTBSVB|GOTBSSL)) {
      case 0:
         bs = (ui32)NPC.dig; break;
      case GOTBSVB:
         if (RK.bssel & RK_BSVERTB) bs = (ui32)NPC.dig; break;
      case GOTBSSL:
         if (RK.bssel & RK_BSSLASH) bs = (ui32)NPC.dig; break;
      default:
         abexit(192);
         } /* End switch */
      if (bs > MxBS) abexit(192);
      code |= bs << RK_BS;
      break;
      } /* End 'B' local scope */

   case 'J' :                    /* Left Justify */
      code |= RK_LFTJ;           /* Insert code */
      jfbl = gotnum ? NPC.dig : JFULLWID;
      break;

   case 'r' :                    /* Repeat count, separate items */
      if (!gotnum) abexit(186);
      rep = NPC.dig;
      if (rep == 0) abexit(187);
      NPC.pfflgs |= LISTSTEP;
      break;

   case 'R' :                    /* Repeat count, data array */
      if (!gotnum) abexit(186);
      rep = NPC.dig;
      if (rep == 0)
         rep = 1, NPC.pfflgs |= SKIPITEM;
      else if (rep > 1) NPC.pfflgs |= PTRITEM;
      break;

   case 'v' :                    /* Underflow/hex width control */
   case 'V' :
      if (gotnum) abexit(185);
      code |= RK_UFLW;
      break;

   case '0' :                    /* Pad output with zeros */
      if (gotnum) abexit(185);
      code |= RK_NPAD0;
      break;

   case '~' :                    /* Output blanks if item skipped */
      if (gotnum) abexit(185);
      NPC.pfflgs |= SKIPQABL;
      break;

   case '#' :                    /* Classical alternate forms */
      if (gotnum) abexit(185);
      NPC.pfflgs |= ALTFORM;
      break;

   case '^' :                    /* Override item size */
      if (!gotnum) abexit(186);  /*** CAUTION: the item size is ***/
      iadv = NPC.dig;            /*** taken to be in bytes!  ***/
      NPC.pfflgs |= GOTIADV;
      break;

   case '&' :                    /* Argument is a pointer to the item */
      if (gotnum) abexit(185);
      NPC.pfflgs |= PTRITEM;
      break;

   case '-' :                    /* Classical left-justify */
      if (gotnum) abexit(185);
      code |= RK_LFTJ;              /* Treat same as '0J' */
      jfbl = JFULLWID;
      break;

   case '+' :                    /* Add plus sign to positives */
      if (gotnum) abexit(185);
      code |= RK_PLUS;
      break;

   case ' ' :                    /* Protect values with a blank */
      if (gotnum) abexit(185);
      code |= RK_LSPC;
      break;

   case '?' :                    /* Conditional output */
      if (gotnum) abexit(185);
      NPC.dig = va_arg(NPC.lptr, int);
      if (NPC.dig == 0) NPC.pfflgs |= SKIPITEM;
      break;

   default: goto WidthState;

      } /* End state 2 (flags) format switch */

   ++NPC.fptr;
   gotnum = (byte)digits();      /* Check for count before code */
   } /* End while *NPC.fptr */

/*=====================Resume normal indenting========================*/

/*---------------------------------------------------------------------*
*  State 3:  Read width, check for decimal specification.              *
*---------------------------------------------------------------------*/

WidthState:
   if (gotnum) {
      width = NPC.dig;
      NPC.pfflgs |= GOTWID;
      }
   if (*NPC.fptr == '.') {
      ++NPC.fptr;
      if (*NPC.fptr == 'A') {       /* Auto decimal */
         code |= RK_AUTO;
         ++NPC.fptr;
         dec = 0;
         NPC.pfflgs |= GOTAUTO;
         goto SizeState;
         }
      else if (*NPC.fptr == '<') {  /* Limited auto decimal */
         code |= RK_AUTO;
         ++NPC.fptr;
         }
      gotnum = (byte)digits();      /* Read decimal from format */
      if (!gotnum) abexit(186);
      if (NPC.dig > MxDec) abexit(193);
      dec = NPC.dig;
      NPC.pfflgs |= GOTDEC;
      }

/*---------------------------------------------------------------------*
*  State 4:  Read argument size specification.                         *
*  Note:  If there is more than one size code, the second one will     *
*  fall into the type switch, be unrecognized, give an abexit(180).    *
*---------------------------------------------------------------------*/

SizeState:
   switch (*NPC.fptr) {

   case 'h' :                    /* Short or char */
      if (NPC.fptr[1] == 'h') {     /* 'hh' is char */
         code |= RK_NBYTE;
         ++NPC.fptr; }
      else
         code |= RK_NHALF;
      break;

/* N.B.  There is no way known to GNR to find out the size of size_t
*  at preprocessor time, so we have defined it as STSIZE in sysdef.h
*  and all will be well if that variable is assigned its correct
*  value when new system definitions are added.  */
#if STSIZE == 4
   case 'z' :                    /* size_t, whatever it is */
#endif
   case 'j' :                    /* 32-bit (int_max in some vers.) */
      code |= RK_NI32;
      break;

   case 'l' :                    /* Long or long long */
      if (NPC.fptr[1] == 'l') {     /* 'll' is long long */
         code |= RK_NI64;
         ++NPC.fptr; }
      else
         code |= RK_NLONG;
      break;

#if STSIZE == 8
   case 'z' :                    /* size_t, whatever it is */
#endif
   case 'w' :                    /* Wide ( = long long) */
      code |= RK_NI64;
      break;

   default: goto TypeState;

      } /* End state 3 (size code) switch */

   ++NPC.fptr;

/*---------------------------------------------------------------------*
*  State 5:  Read argument type spec and process conversion.           *
*---------------------------------------------------------------------*/

TypeState:
   /* Per man page, left-justify overrides zero padding */
   if (code & RK_LFTJ) code &= ~RK_NPAD0;

   /* Set item size (can be overridden in type switch) */
   itemsize = wnclen(code);

   /* Settings that depend on the type of conversion but need be
   *  performed only once, outside the repeat loop */
   kcsw = kcnone;                /* JIC */
   switch (*NPC.fptr) {
   case 'b' :                    /* Write blanks */
      if (!(NPC.pfflgs & GOTWID)) abexit(186);
      NPC.pfflgs |= NOWIDCK;
      kcsw = kcblnks;
      break;
   case 'c' :                    /* Int as single char */
      if (code & RK_NI128) abexit(180);
      padchar = (code & RK_NPAD0) ? '0' : ' ';
      kcsw = kcchar;
      break;
   case 'C' :                    /* Reserved for complex numbers */
      kcsw = kccmplx;               /* JIC */
      abexit(180);
   case 'd' :                    /* Signed fixed-point */
   case 'D' :
   case 'i' :
   case 'I' :
      code |= RK_IORF;
      kcsw = kcfixpt;
      break;
   case 'e' :                    /* Exponential */
   case 'E' :
#if RK_EFMT != 0                    /* JIC */
      code |= RK_EFMT;
#endif
      if (code & RK_NI32) {
         if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING)) {
#if RK_SNGL != RK_NI32  /* JIC */
            code = code & ~RK_NI32 | RK_SNGL;
#endif
            itemsize = ESIZE;
            }
         else abexit(190);
         }
      else
         itemsize = DSIZE;
      if (!(NPC.pfflgs & (GOTDEC|GOTAUTO))) dec = DFLT_DECIM;
      else if (NPC.pfflgs & ALTFORM && !dec) code |= RK_D;
      kcsw = kcexp;
      break;
   case 'g' :                    /* Floating point (w/RK_UFLW) */
   case 'G' :
      code |= RK_UFLW;
      /* ... drop through to case 'f' ... */
   case 'f' :                    /* Floating point */
   case 'F' :
      code |= RK_IORF;
      if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING)) code |= RK_SNGL;
      if (!(NPC.pfflgs & (GOTDEC|GOTAUTO))) dec = DFLT_DECIM;
      else if (NPC.pfflgs & ALTFORM && !dec) code |= RK_D;
      kcsw = kcfloat;
      break;
   case 'k' :                    /* Wide seed */
      itemsize = sizeof(wseed);
      kcsw = kcwseed;
      break;
   case 'K' :                    /* Option keys */
      /* Access keys before loop and
      *  fake '-' flag unless 'nJ' already given.  */
      kokeys = va_arg(NPC.lptr,char *);
      if (!kokeys) abexit(191);
      if (!(code & RK_LFTJ))
         code |= RK_LFTJ, jfbl = JFULLWID;
      kcsw = kckeys;
      break;
   case 'n' :                    /* Write length back to caller */
      NPC.pfflgs |= (PTRITEM|NOWIDCK);    /* Item must be a pointer */
      kcsw = kcnout;
      break;
   case 'o' :                    /* Octal */
      if (bs | dec) abexit(194);
      code |= RK_OCTF;
      if (NPC.pfflgs & ALTFORM) code |= RK_Oct0;
      kcsw = kcfixpt;
      break;
   case 'p' :                    /* Pointer */
      if (bs | dec) abexit(194);
      code = code & RK_LFTJ | (RK_LSPC|RK_NUNS|RK_NZTW|RK_NZ0X|RK_HEXF);
#if PSIZE == 4
      code |= RK_NI32;
#else
      code |= RK_NI64;
#endif
      itemsize = PSIZE;
      kcsw = kcfixpt;
      break;
   case 'q' :                    /* Double-precision floating point */
   case 'Q' :
      if (code & RK_NI128) abexit(190);
      code |= (RK_DBL|RK_IORF);
      if (!(NPC.pfflgs & (GOTDEC|GOTAUTO))) dec = DFLT_DECIM;
      else if (NPC.pfflgs & ALTFORM && !dec) code |= RK_D;
      itemsize = DSIZE;
      kcsw = kcdbl;
      break;
   case 's' :                    /* String */
      NPC.pfflgs |= (PTRITEM|NOWIDCK);    /* Item must be a pointer */
      /* At the point where indexing occurs below in the rep loop,
      *  the string length is not yet known (and can vary from one
      *  iteration to the next), so we use the width here and
      *  declare an error if indexing is being done and a width
      *  was not specified.  */
      if (ndx) {
         if (NPC.pfflgs & GOTWID) itemsize = width;
         else abexit(188);
         }
      kcsw = kcstring;
      break;
   case 'u' :                    /* Unsigned integer */
   case 'U' :
      code |= (RK_NUNS|RK_IORF);
      kcsw = kcfixpt;
      break;
   case 'x' :                    /* Hexadecimal, lower case */
      /* The documentation for the standard routine says the argument
      *  is always unsigned, and most apps probably want it that way--
      *  the user can call wbcdwt() directly if signed is wanted, or
      *  we could invent a new type code or flag for this purpose.  */
      code |= RK_NZLC;
      /* ... drop through to case 'X' ... */
   case 'X' :                    /* Hexadecimal, upper case */
      if (bs | dec) abexit(194);
      code |= (RK_HEXF|RK_NUNS);
      if (NPC.pfflgs & ALTFORM) code |= RK_NZ0X;
#if RK_NZTW != RK_UFLW
      if (code & RK_UFLW) code = code & ~RK_UFLW | RK_NZTW;
#endif
      kcsw = kcfixpt;
      break;
      } /* End pre-loop type switch */

   /* Check width and move into wbcdwt code unless this is 'n' code,
   *  a string or blanks, which have a larger max width tolerance.  */
   if (!(NPC.pfflgs & NOWIDCK)) {
      if (width <= 0 || width > RK_MXWD + 1) abexit(187);
      code |= (width - 1);
      /* Move decimal setting into wbcdwt code */
      if (dec > 0) code |= (dec + 1) << RK_DS;
      }

   /* If no supervenient dimension, use repeat count as dim */
   if (!(NPC.pfflgs & GOTIADV)) iadv = itemsize;
   if (!(NPC.pfflgs & (INDEXING|LISTSTEP)))
      dim = idim = rep;

   /* Repeat conversion number of times implied by rep */
   while (rep--) {

      /* If accessing arguments via pointers and not in the midst
      *  of processing an array, update iptr from next argument.  */
      if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING) && dim == idim &&
            kcsw != kcblnks) {
         iptr = va_arg(NPC.lptr,void *);
         if (!iptr) goto EndItAll;
         /* Handle bracket indexing, but only on new pick */
         iptr = (char *)iptr + ndx*idim*iadv;
         }

      /* Output to temp string if unspecified width */
      if (NPC.pfflgs & GOTWID) {
         wdat = NPC.pdat;
         if (wdat + width >= NPC.top) abexit(181);
         }
      else
         wdat = tdat;

      /* Deal with output skipping */
      if (NPC.pfflgs & SKIPITEM) {
         if (NPC.pfflgs & SKIPQABL) {
            if (!(NPC.pfflgs & GOTWID)) abexit(189);
            memset(NPC.pdat, ' ', (size_t)width);
            NPC.pdat += width; NPC.totl += width;
            }
         goto noconv;            /* Skip count update */
         }

      switch (kcsw) {

      case kcblnks :             /* Write blanks */
         memset(NPC.pdat, ' ', (size_t)width);
         NPC.pdat += width; NPC.totl += width;
         continue;

      case kcchar : {            /* Int as single char */
         char *wwdat;
         int  cval;
         memset(wwdat=wdat, padchar, width);
         if (!(code & RK_LFTJ)) wwdat += width - 1;
         cval = (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING)) ?
            *(int *)iptr : va_arg(NPC.lptr, int);
         *wwdat = (char)cval;
         RK.length = 0;
         break;
         } /* End kcchar local scope */

      case kcfixpt :             /* Fixed-point */
         if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING)) {
            wbcdwt(iptr, wdat, code);
            }
         else if (itemsize == WSIZE) {
            si64 warg = va_arg(NPC.lptr, si64);
            wbcdwt(&warg, wdat, code);
            }
         else {
            int iarg = va_arg(NPC.lptr, int);
            code &= ~RK_NI128;   /* Make it int default */
            wbcdwt(&iarg, wdat, code);
            }
         break;

      case kcexp :               /* Exponential */
         if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING)) {
            if (code & RK_SNGL)
               bcdout(code, wdat, (double)(*(float *)iptr));
            else
               bcdout(code, wdat, *(double *)iptr);
            }
         else {
            double darg = va_arg(NPC.lptr, double);
            bcdout(code, wdat, darg);
            }
         break;

      case kcfloat :             /* Floating point */
         if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING)) {
            bcdout(code, wdat, (double)(*(float *)iptr));
            }
         else {
            double darg = va_arg(NPC.lptr, double);
            bcdout(code, wdat, darg);
            }
         break;

      case kcdbl :               /* Double floating point */
         if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING)) {
            bcdout(code, wdat, *(double *)iptr);
            }
         else {
            double darg = va_arg(NPC.lptr, double);
            bcdout(code, wdat, darg);
            }
         break;

      case kcwseed :             /* Wide (64-bit) seed */
         if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING))
            wseedout((wseed *)iptr, wdat, code);
         else {
            wseed warg = va_arg(NPC.lptr, wseed);
            wseedout(&warg, wdat, code);
            }
         break;

      case kckeys : {            /* Option codes */
         ui32 kitem;
         /* Pick up item in kitem, coerce to ui32 */
         if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING)) {
            switch (itemsize) {
            case 1: kitem = (ui32)(*(byte *)iptr); break;
            case 2: kitem = (ui32)(*(ui16 *)iptr); break;
            case 4: kitem =        *(ui32 *)iptr ; break;
            default:  abexit(180);
            }}
         else {
            /* Due to type promotion, arg will always be int */
            kitem = va_arg(NPC.lptr, ui32);
            }
         /* If width specified, let mcodprt fill it, but must copy
         *  result to output buffer.  If width not specified, we
         *  can just reset the wdat ptr and cleanup code below will
         *  do the copy.  */
         if (NPC.pfflgs & GOTWID)
            memcpy(wdat, mcodprt(kitem, kokeys, width), width);
         else
            wdat = mcodprt(kitem, kokeys,
               (jfbl < JFULLWID) ? -width : width);
         break;
         } /* End kitem local scope */

      case kcnout :              /* Return length of data written */
         switch (itemsize) {
         case 1: *(byte *)iptr = (byte)NPC.totl; break;
         case 2: *(ui16 *)iptr = (ui16)NPC.totl; break;
         case 4: *(ui32 *)iptr = (ui32)NPC.totl; break;
         case 8: *(ui64 *)iptr = jeul((ui32)NPC.totl); break;
            }
         goto noconv;            /* Skip count update */

      case kcstring : {          /* String */
         /* Note:  Because the tdat space is limited, this code
         *  handles the string movement directly rather than leave
         *  it to the code below in order to allow left and right
         *  padding even if the string is longer than tdat.  */
         int ltot,navail;           /* Lengths: total, avail for pad */
         int llp = 0, lrp = 0;      /* Length of left, right padding */
         int lst = (NPC.pfflgs & GOTDEC) ?   /* Length of string */
            strnlen(iptr, dec) : strlen(iptr);
         if (NPC.pfflgs & GOTWID) {
            if (lst > width) lst = width;
            navail = width - lst;
            if (code & RK_LFTJ)
               lrp = min(navail, jfbl);
            else
               llp = navail;
            }
         else if (jfbl < JFULLWID) lrp = jfbl;
         if (!(NPC.pfflgs & GOTIADV)) iadv = lst;

         ltot = llp + lst + lrp;
         if (NPC.pdat + ltot >= NPC.top) abexit(181);
         if (llp > 0)
            memset(NPC.pdat, ' ', llp), NPC.pdat += llp;
         memcpy(NPC.pdat, iptr, lst);
         NPC.pdat += lst;
         if (lrp > 0)
            memset(NPC.pdat, ' ', lrp), NPC.pdat += lrp;
         NPC.totl += ltot;
         goto oneconv;
         } /* End kcstring local scope */

      default:                   /* Invalid format code */
         abexit(180);

         } /* End format type switch */

      /* Account for length of data written.  If using temporary
      *  data field, now that width is known, check for overflow
      *  and copy data to pdat.  */
      {  int tuw;                   /* Used width */
         int tmw = RK.length + 1;   /* Minimum width */
         int tpw = tmw + jfbl;      /* Padded width */
         if (NPC.pfflgs & GOTWID) {
            tuw = width;
            if ((code & RK_LFTJ) && (tpw < tuw)) tuw = tpw;
            }
         else {
            char *wwdat;
            if (code & RK_LFTJ) {
               tuw = (jfbl >= JFULLWID) ? tmw : tpw;
               wwdat = wdat;
               }
            else {
               tuw = tmw;
               wwdat = wdat + width - tuw;
               }
            if (NPC.pdat + tuw >= NPC.top) abexit(181);
            memcpy(NPC.pdat, wwdat, tuw);
            }
         NPC.pdat += tuw, NPC.totl += tuw;
         } /* End tuw,tmw,tpw local scope */

oneconv:
      ++RK.numcnv;         /* Count conversions */

      /* Advance argument pointer even if conversion skipped
      *  (harmless if not a PTRITEM), and reduce indexing count.
      *  Turn off indexing when count reaches 0.  */
noconv:
      iptr = (char *)iptr + iadv;
      if (NPC.pfflgs & (PTRITEM|INBKTS|INDEXING) && --dim <= 0) {
         dim = idim = 0;
         NPC.pfflgs &= ~INDEXING;
         }

      } /* End rep loop */

   ++NPC.fptr;               /* On to next format code */
   goto RestartAfterConversion;

   } /* End rkprintf() */

