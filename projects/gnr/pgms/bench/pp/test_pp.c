/* PP worker function for d3benchmark test */

/* Include standard library functions */

#include <stdio.h>
#include <stdlib.h>

#include "timemgr.h"	      /* Timer functions */
#include "dspAPI.h"	      /* DSP Command interface */
#include "param.h"	      /* System dependent, and compatibility  */

/* Define parameters that aren't worth varying in input file
      PT = positive firing threshold for a cell
      MTI = modification threshold on output of a cell
      MTJ = modification threshold on input to a connection
      ET = excitatory threshold for an input to a connection          */

#define  PT  0.25
#define MTI  0.3
#define MTJ  0.4
#define  ET  0.2

   typedef unsigned char byte;

   struct CONNDATA {          /* Data for a single connection */
      short int lij;          /* Number of source cell */
      byte cij;               /* Strength of connection (S7) */
      };

   struct CONNBLK {           /* Connection-type information block */
      struct CONNBLK *pct;    /* Pointer to next CONNBLK */
      struct CELLBLK  *psrc;  /* Pointer to source cell type */
      double chunksize[2];    /* Range of a generated connection */
/* [2] is kludge because double on PP is half size on MP */
      long int nconns;        /* Number of connections */
      int source;             /* Serial number of source cell type */
      int rule;               /* Connection generating rule */
      long int scale;         /* Scale factor (S8) */
      long int das[4];        /* Detailed amp stats */
      long int ax;            /* Intermediate afferent sum (S15) */
      };

   struct CELLBLK {           /* Cell-type information block */
      struct CELLBLK *play;   /* Pointer to next CELLBLK */
      struct CONNBLK *pct1;   /* Pointer to first CONNBLK */
      struct CONNDATA *prd;   /* Pointer to actual connection data */
      long int ncells;        /* Number of cells of this type */
      long int nconntypes;    /* Number of connection types */
      long int nconntotal;    /* Total number of connections */
      long int delta;         /* Amplification factor (S10) */
      byte *psi;              /* Pointer to s(i) data */
      byte *ps2;              /* Pointer to alternate (new) s(i) */
      };


int far niterations;
struct CELLBLK far *play1;
  
shared void test_pp( DSPARG *argBuf ) {
   int num;
   int ji,jl,js,jx,jc;        /* Iter, cell, conn type & data counters */
   int mti,mtj,et;            /* Working thresholds (S8) */

   struct CELLBLK *il,*ll;    /* Pointer to current, last CELLBLK */
   struct CONNBLK *ix,*lx;    /* Pointer to current, last CONNBLK */
   struct CONNDATA *ic,*lc;   /* Pointer to current connection data */
   byte *is,*is2,*psj;        /* Pointers to state variables */
   int wksj,sjmet,wkcij;      /* s(j) (S8); s(j) - et (S8); cij (S7) */
   int simmti,sjmmtj;         /* s(i) - mti (S8); s(j) - mtj (S8) */
   long int wksum;            /* Working sum for s(i) */
   int ampcase;               /* Amplification case for "DAS" */
   long int pt;               /* Working output threshold */

   niterations = (int) argBuf->argv[0];
   play1 = (struct CELLBLK *) argBuf->argv[1];

/*--------------------------------------------------------------------*/
/*                                                                    */
/*                  PERFORM THE ACTUAL SIMULATION                     */
/*                                                                    */
/*--------------------------------------------------------------------*/

   pt  = (long int)(8388608.0*PT);  /* PT with 23 fraction bits */
   mti = (int)(256.0*MTI);
   mtj = (int)(256.0*MTJ);
   et  = (int)(256.0*ET);

/* Perform 'niterations' iterations.  Note that in general, it is not
   possible to parallelize by having different processors work on
   different iterations because the state of the environment will
   depend on outputs generated by the automaton in the previous step. */

   for (ji=1;ji<=niterations;ji++) {

#if 0
/* DEBUG DEBUG DEBUG */
      printf("State at iteration %d\n",ji);
/*      for (jl=1,il=play1;il!=NULL;il=il->play,jl++) {*/
         il=play1;
      for (i=0; i <3; i++) il=il->play;
         jl=1;

         ic = il->prd; lc = ic;
/*         for (js=0,is=il->psi;js<il->ncells;js++) {*/
           js=0; is=il->psi;

            printf("   s(%d,%d) = %6.3f\n",jl,js,(float)(*is++)/256.0);
            for (jx=1,ix=il->pct1;ix!=NULL;ix=ix->pct,jx++) {
               printf("     l(%d): ",jx);
               for (jc=0;jc<ix->nconns;jc++,lc++)
                  printf("%7d",lc->lij);
               printf("\n");
               printf("     c(%d): ",jx);
               for (jc=0;jc<ix->nconns;jc++,ic++) {
                  wkcij = ic->cij >= 128 ? ic->cij - 256 : ic->cij;
                  printf("%7.3f",(float)wkcij/128.0);}
               printf("\n");}
/* ENDDEBUG ENDDEBUG ENDDEBUG */
#endif

/* Evaluate responses for all defined cell types.  In general, one
   will want to allow different processors to work on different cell-
   types.  This is complicated by the fact that different celltypes
   have different numbers of connections, so the processors will not
   all finish together.  In present models, the order of evaluation
   of celltypes is deterministic and the resulting states are used
   for evaluation of celltypes defined later.  This restriction may
   be relaxed in the future.  In any event, cells can be made to
   appear to be updated simultaneously by keeping multiple state
   vectors and switching pointers at appropriate times, as is done
   in the present program.  In the real Darwin III program, there
   is an 'UPWITH' option to specify that a group of celltypes are
   to be updated simultaneously.                                      */

/* In systems with relatively few processors, it will probably be
   sufficient to process cell types sequentially, exercising parallelism
   at the level of cells of the same type.  In the connection machine,
   there will typically be fewer cells of one type than there are
   processors.  Designs to consider are (1) to process the entire
   network simultaneously, with one or more cells of whatever type
   assigned to a processor, masking each processor off when it has
   completed the relevant number of connections; or (2) to distribute
   connections, rather than cells, over the processors.  This would
   assure a very uniform load distribution, but would have the added
   complication of needing to bring the results together to update the
   cell variables.                                                    */

      for (il=play1;il!=NULL;il=il->play) {

/* For each iteration, the "DAS" statistics are collected in the
   CONNBLKs.  This calculation is included in the benchmark mainly
   to see how different parallel architectures deal with possibly
   asynchronous updating of a variable from a number of different
   processes (in this case, different connections getting updated).
   At this time, the statistics must be initialized to zero.          */

         for (ix=il->pct1;ix!=NULL;ix=ix->pct) {
            ix->das[0]=0;ix->das[1]=0;ix->das[2]=0;ix->das[3]=0;}

/* Evaluate responses for all cells of this type */

         ic = il->prd;
         for (js=1,is=il->psi,is2=il->ps2;js<=il->ncells;js++) {

/* Evaluate responses for all connection types associated with each
   cell type.                                                         */

            wksum = 0; /* Clear the working s(i) sum */
            simmti = (int)*is++ - mti; /* Temp term needed for amplif */
            for (ix=il->pct1;ix!=NULL;ix=ix->pct) {

/* Calculate contributions of all connections of current type */

               ix->ax = 0; /* Clear the connection-type sum.  This is
                              stored in the data block for other uses */
               psj = ix->psrc->psi; /* Locate the source cells */
               for (jc=0;jc<ix->nconns;jc++,ic++) {
                  wksj  = (int)psj[ic->lij];
                  sjmet = wksj - et;
                  wkcij = ic->cij >= 128 ? ic->cij - 256 : ic->cij;
                  if (sjmet > 0) ix->ax += sjmet*wkcij;

/* Perform amplification if delta != zero.  Only the "4-way" rule
   is implemented in this "benchmark".  To make life simpler,
   the 'phi' factor is ignored (i.e. taken to be 1.0), and scaling
   is fudged to make intermediate results fit in 32-bit registers.
   "DAS" statistics are always collected.                             */

                  if (il->delta) {
                     sjmmtj = wksj - mtj;
                     ampcase = 0;
                     if (simmti < 0) ampcase += 2;
                     if (sjmmtj < 0) ampcase += 1;
                     ix->das[ampcase]++;
                     wkcij += (il->delta*simmti*sjmmtj)>>19;
                     if (wkcij > 127) wkcij = 127;
                     if (wkcij <-127) wkcij =-127;
                     ic->cij = (byte) wkcij;}

                  } /* End loop over individual connections */

               /* Scale the connection-type contribution and add it in */
               ix->ax *= ix->scale;
               wksum += ix->ax;
               } /* End loop over connection types */

            /* Force the final s(i) into range 0 to 255 */
            if (wksum < pt) wksum = 0;
            else {wksum = wksum>>15; if (wksum > 255) wksum = 255;}
            *is2++ = (byte)wksum;
            } /* End loop over cells of current type */

         /* Reverse the new and old states of the cells */
         psj = il->psi; il->psi = il->ps2; il->ps2 = psj;
         } /* End loop over cell types */

      } /* End loop over requested number of iterations */

  } 
