/* (c) Copyright 1991-2003, Neurosciences Research Foundation, Inc. */
/* $Id: d1go.c 26 2009-12-31 21:09:33Z  $ */
/***********************************************************************
*                             CNS Program                              *
*                                d1go                                  *
*                                                                      *
*  Evaluate Darwin I input arrays:                                     *
*     1) Evaluate response scores of all cells to new input            *
*     2) Exchange scores to all nodes for input to Darwin III reps     *
*     3) Perform amplification                                         *
*  This routine is called on all nodes from main after general input   *
*     broadcast and before d3go, but only if D1 is defined to pre-     *
*     processor and RP->pd1b1 is not NULL.  Should work in serial too. *
*  A key difference from d3go is that updating of response scores is   *
*     done "in place" because there is no need to refer to old scores  *
*     while new ones are being calculated.  pd1s points to the full    *
*     array of scores within which exchange takes place.  Therefore,   *
*     each node must begin storing at offset mys1 into this array.     *
*  Amplification is rather complex.  It implements these principles:   *
*     1) Recognizers generated by amplification must be distributed    *
*        randomly throughout the system, and in different places each  *
*        time step.  (Modified by nsprd parameter, 6/12/92)            *
*     2) The process must be semideterministic, in the sense that if   *
*        more than one generated recognizer is scheduled to replace a  *
*        given cell, it is arbitrary which one is stored, but the same *
*        one will be stored when run on the same number of nodes.  The *
*        destinations and contents of generated recognizers are fully  *
*        deterministic.  Combined with requirement (1), this is imple- *
*        mented by packaging the destination with the new recognizer   *
*        for delivery across the network, and by deterministically     *
*        setting random number seeds for each cell amplified.          *
*     3) No cell is replaced before it has a chance to be amplified.   *
*        This requires that no cell that is above ampt is replaced in  *
*        the same time step.  This is enforced by d3grp1, which makes  *
*        sure that rept < ampt always.                                 *
*     4) If the number of generated recognizers exceeds the size of    *
*        the system, enough are dropped so that on average, each cell  *
*        is replaced only once. This is mostly to avoid communications *
*        deadlock and should rarely occur with reasonable parameters.  *
*     5) If the "mutate-self" bit is set, an amplified recognizer is   *
*        itself mutated.  Copies may or may not be made according to   *
*        the ampf,ampm settings.  This option may be useful for making *
*        a "novelty detector" repertoire.                              *
*                                                                      *
*  V5C, 12/02/91, GNR - Initial version                                *
*  Rev, 02/26/92, GNR - Switch to normalized response scores           *
*  Rev, 05/20/92, ABP - Add stattmr() calls                            *
*  V5E, 08/09/92, GNR - Fix bug when negative copies calculated        *
*  Rev, 12/10/92, ABP - Add HYB code, just update seeds on host        *
*  Rev, 08/17/93, GNR - Remove hypercube and 2**n dependency           *
*  Rev, 11/27/96, GNR - Remove support for non-hybrid version          *
*  Rev, 10/18/01, GNR - Separate kd1 into three components             *
*  V8C, 02/22/03, GNR - Cell responses in millivolts, add conductances *
*  ==>, 02/17/05, GNR - Last mod before committing to svn repository   *
***********************************************************************/

/*=====================================================================*
*                          WARNING 06/12/92                            *
*  Because of urgent request from GME to add new facilities relating   *
*  to surround radius, maxhits, and spread, a nondeterministic amplif  *
*  situation temporarily exists.  See design notes for what must be    *
*  done to fix this situation.   -GNR                                  *
*=====================================================================*/

#define D1TYPE  struct D1BLK

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sysdef.h"
#include "rkarith.h"
#include "d3global.h"
#include "d1def.h"
#include "bapkg.h"

/* Define size of angetp work areas (two are allocated
*  for amplification communication and then released). */
#define PotSize   6144
#define WS          16     /* Scale of wobblewt */

/* Macro for computing node a target cell lives on */
#define Loc(t) (NC.headnode + \
   ((t < pd1->cut) ? t/(pd1->cpn+1) : (t-pd1->crn)/pd1->cpn))

#ifdef PAR
/* OffPath returns 0 if current partner is on shortest path to target.
*  This 'backwards' definition allows test for forwarding on a link
*  to be combined with test for whether current partner is exact target.
*  OffPath for RING works by determining whether the node difference
*  is an odd or even multiple of half the number of nodes.  (3/2) the
*  total is added to force positive dividend and reverse the parity.
*  Result returned looks like this (let T = total num of nodes):
*               |.......|.......|.......|.......|
*  Node diff:  -T      -T/2     0      +T/2    +T  (+|- T is max diff)
*  UpDown > 0:  1 0 0...0 1 1...1 0 0...0 1 1...1
*  UpDown < 0:  1 1 1...0 0 0...1 1 1...0 0 0...1
*  Note that we always send to the half-way-around nodes regardless
*  of UpDown direction, and never send to self (0,+T,-T).
*/
#ifdef HYPERCUBE
#define OffPath(n) (((n) ^ nnext) & chan)
#else /* is RING */
#define OffPath(n) (((SesquiSize - UpDown*((n)-NC.node))/HalfSize) & 1)
#endif
#endif /* PAR */

#ifndef PAR0               /* Not needed on host */
/*---------------------------------------------------------------------*
* AmpNum - Compute number of copies to generate during amplification   *
*                                                                      *
*  Arguments:                                                          *
*     pd1      Ptr to current D1BLK                                    *
*     ps       Ptr to cell whose amplif count is wanted                *
*                                                                      *
*  Optimization note:                                                  *
*     This routine could remember the last cell number it was called   *
*  with, and if just one less than the cell number in the current      *
*  call, it could use the old surround count, minus the guy that went  *
*  off on the left, plus the guy that came in on the right.            *
*---------------------------------------------------------------------*/

static int AmpNum(struct D1BLK *pd1, d1s_type *ps) {

   /* Begin with basic amplification formula as documented */
   int lampt  = pd1->ampt;       /* Local copy of ampt */
   int copies = pd1->ampf + (*ps - lampt)*pd1->ampm;
   if (copies < 0) copies = 0;

   /* Check the surround if one is specified and reduce copies.
   *  (This code works with copy count while it is still (S8)) */
   if (pd1->nsurr) {
      register d1s_type *ps1=ps,*ps2=ps;
      register long ii,hits = 0;
      for (ii=0; ii<pd1->nsurr; ii++) {
         if (  ps1 <= pd1->psr1) ps1 = pd1->psr2;
         if (++ps2 >= pd1->psr2) ps2 = pd1->psr1;
         if (*--ps1 >= (unsigned)lampt) ++hits;
         if (*ps2   >= (unsigned)lampt) ++hits;
         } /* End counting surround */
      if (hits) {
         ii = pd1->nsmxh - hits;
         /* (Use dm64nq here if pd1->nsmxh*max copies > 1L<<24) */
         if (ii > 0) copies = (copies*ii)/pd1->nsmxh;
         else        copies = 0;
         } /* End adjusting copy count for surround */
      } /* End checking surround */

   /* Scale copy count to integer */
   copies >>= 8;

   /* Note that pd1->nsprd is (S1), i.e. is really 2*(spread size) */
   return min(copies,pd1->nsprd);
   } /* End Amp */


/*---------------------------------------------------------------------*
*                d1gmrec - Generate mutated recognizer                 *
*                                                                      *
*  Arguments:                                                          *
*     pd1      Ptr to current D1BLK, where mutfreq, etc. are gotten    *
*     gcn      Node-relative number of current cell                    *
*     seed     Generating seed (already updated by udevskip)           *
*     dest     Destination for result of length pd1->nbyt.             *
*---------------------------------------------------------------------*/

static void d1gmrec(struct D1BLK *pd1, long gcn, long seed,
   byte *dest) {

   int ibit;                  /* Bit counter */

   /* Copy unmodified recognizer to destination */
   memcpy((char *)dest,(char *)pd1->pd1r+gcn*pd1->nbyt,pd1->nbyt);

   /* Loop over bits, inverting with frequency mutfreq */
   if (pd1->mutfreq) for (ibit=1; ibit<=pd1->nbpe; ibit++)
      if (udev(&seed) < pd1->mutfreq) bitcmp(dest,ibit);
   } /* End d1gmrec */
#endif

/*---------------------------------------------------------------------*
*                        d1go executable code                          *
*  Arg:  pwk is ptr to work area holding max(pd1->nbyt) bytes          *
*---------------------------------------------------------------------*/

void d1go(byte *pwk) {

   struct D1BLK *pd1;         /* Ptr to current D1BLK */
   long nelt;                 /* Total cells in this rep block */

#ifndef PAR0
   byte *pr;                  /* Ptr to repertoire data */
   d1s_type *ps;              /* Ptr to computed scores */
   d1s_type *ps1,*ps2;        /* Limiting values of ps (node,rep) */
   d1s_type *psi;             /* Local copy of pd1->pd1s */
   long ksta =                /* Statistics test mask */
         (RP->CP.runflags & RP_NOSTAT) ? 0 : KD1_NOST;
#endif
   long lkd1o;                /* Local copy of pd1->kd1o */
   long lnbpe;                /* Local copy of pd1->nepr */
   long lnepr;                /* Local copy of pd1->nepr */

#ifndef PAR0
   long mylo,myhi;            /* First, last+1 cell on node */

   int irep;                  /* Number of the indexed repertoire */
   int lli1r;                 /* Local copy of pd1->li1r */
   int lnbyt;                 /* Local copy of pd1->nbyt */
#endif

/* Loop over all Darwin 1 blocks */

   for (pd1=RP->pd1b1; pd1; pd1=pd1->pnd1b) {

/* Calculate constants generally used in the three stages below */

      lkd1o = pd1->kd1o;
      lnbpe = pd1->nbpe;
      lnepr = pd1->nepr;
      nelt = pd1->nd1r*lnepr;    /* Total cells in block */
#ifndef PAR0
      lli1r = pd1->li1r;
      lnbyt = pd1->nbyt;
      psi   = pd1->pd1s;
      myhi = (mylo = pd1->lod1e) + pd1->mynd1;

/*---------------------------------------------------------------------*
*   Stage I:  Calculate response scores of all cells in repertoire     *
*---------------------------------------------------------------------*/

      stattmr(OP_PUSH_TMR, D1G1_TMR);

      {  /* (One level of indenting suppressed.) */
      d1s_type *pcwnrs;          /* Ptr to cell where nxt rep starts */
      byte *pq = RP->pbcst + pd1->odin; /* Ptr to current input data */
      void (*Match)(void *, long, void *);
                                 /* Ptr to data matching function */

      long mys1,mys2;            /* First, last cell being evaluated */
      long ww = pd1->wobblewt;   /* Local copy of wobble weight */
      long normfac;              /* Normalization factor for wobbles */

      int kndx =                 /* Index mode */
         RP->pd1b1->kd1o & KD1_INDX;
      int score;                 /* Match score (S8) */

/* Set up loop over cells:
*     In any event, update only cells belonging to my node.
*     If in KD1_INDX mode, update only such of those cells
*        that also belong to the selected "repertoire".  */

      pr = pd1->pd1r;            /* Pick up rep data ptr */

      if (kndx) {
         /* If not keeping previous scores, erase them for my node */
         if (!(lkd1o & KD1_KEEP))
            memset((char *)psi+mylo,0,pd1->mynd1);
         /* Get repertoire index */
         memcpy((char *)&irep,(char *)pq,sizeof(int));
         /* Reduce range to only cells in selected repertoire */
         mys2 = (mys1 = irep*lnepr) + lnepr;
         mys1 = max(mys1,mylo);
         mys2 = min(mys2,myhi);
         /* Omit this node if no selected cells fall on it */
         if (mys1 >= mys2) goto SkipMatching;
         pq += sizeof(int);            /* Skip over rep index */
         pr += (mys1-mylo)*lnbyt;      /* Locate rep data used */
         } /* End if INDX mode */
      else {
         mys1 = mylo, mys2 = myhi;     /* Calc all cells on node */
         irep = mys1/lnepr;            /* Calc repertoire index */
         pq += irep*lli1r;             /* Skip over input data for
                                       *  reps on previous nodes */
         } /* End else not INDX mode */

/* Skip over group information in input records */

      if (!(lkd1o & KD1_VER1)) pq += sizeof(short);

/* Set up matching function and normalizing factor for wobble scores.
/* Rev, 12/30/08, GNR - Replace jm64nb -> mssle for overflow check  */

      Match = (lkd1o & KD1_XOR) ? bytnxr : bytand;
      if (ww) {
         normfac = mssle(lnbpe,(1L<<WS) + (ww<<1),0,OVF_D1);
         if (RP->ovflow) d3exit(D1WBLO_ERR,NULL,0);
         }

/* Loop over affected cells */

      ps1 = psi + mys1;                /* Ptr to starting cell */
      ps2 = psi + mys2;                /* Ptr to ending cell + 1 */
      pcwnrs = psi + (++irep)*lnepr;
      for (ps=ps1; ps<ps2; ps++,pr+=lnbyt) {

         /* If entering a new repertoire, advance input data
         *  ptr and preset pcwnrs for the next one after that. */
         if (ps == pcwnrs) { pq += lli1r; pcwnrs += lnepr; }

/* Compute match score.  This code is a prime candidate
*  for putting in Assembler if this thing goes at all. */

         /* Data to work area */
         memcpy((char *)pwk,(char *)pq,lnbyt);
         Match(pwk,lnbyt,pr);          /* Perform match */
         score = bitcnt(pwk,lnbyt);    /* Count bits */
         if (ww) {                     /* Handle wobble matches */
            register int wobble;       /* Wobble score */
            register int i;            /* Byte counter */
            register byte c1,c2;       /* Carries (unsigned) */

            /* Do right-shifted match */
            memcpy((char *)pwk,(char *)pq,lnbyt);
            /* This is a klutzy multi-byte right rotate */
            c1 = pwk[lnbyt-1] & 1;
            for (i=0; i<lnbyt; i++) {
               c2 = pwk[i] & 1;
               pwk[i] = (pwk[i]>>1) + (c1<<7);
               c1 = c2;
               }
            Match(pwk,lnbyt,pr);
            wobble = bitcnt(pwk,lnbyt);

            /* Do left-shifted match */
            memcpy((char *)pwk,(char *)pq,lnbyt);
            /* This is a klutzy multi-byte left rotate */
            c1 = pwk[0] & 0x80;
            for (i=lnbyt; i; i--) {
               c2 = pwk[i-1] & 0x80;
               pwk[i-1] = (pwk[i-1]<<1) + (c1>>7);
               c1 = c2;
               }
            Match(pwk,lnbyt,pr);
            wobble += bitcnt(pwk,lnbyt);

            score = ds64nq(0,(score<<WS)+(wobble*ww),8,normfac);
            } /* End wobble matches */
         else                          /* No wobble */
            score = (score<<8)/lnbpe;  /* Normalize score */

         *ps = min(score,0xff);        /* Clip and store result */

/* If statistics requested, accumulate them now.
*  Catch amp stats even if amp is turned off.  */

         if (~pd1->kd1p & ksta) {
            pd1->stats.d1sumsco += score;
            pd1->stats.d1maxsco = max(pd1->stats.d1maxsco,score);
            pd1->stats.d1minsco = min(pd1->stats.d1minsco,score);
            if (score >= pd1->ampt) pd1->stats.d1numgtt++;
            } /* End stats */

         } /* End cell loop */
      if (~pd1->kd1p & ksta) pd1->stats.d1ncyc += 1;
SkipMatching: ;                        /* No cells on this node */
      } /* End matching--resume normal indenting */
      stattmr(OP_POP_TMR,0);

/*---------------------------------------------------------------------*
*      Stage II:  If parallel, exchange scores with other nodes.       *
*---------------------------------------------------------------------*/

#ifdef PAR
      d1exch(pd1,FALSE);
#endif

/*---------------------------------------------------------------------*
*                      Stage III:  Amplification                       *
*---------------------------------------------------------------------*/

      stattmr(OP_PUSH_TMR,D1G3_TMR);
#endif /* ifndef PAR0 */
      if (!(RP->CP.runflags & RP_NOCHNG) &&
         (lkd1o & KD1_MUTS || (pd1->ampf | pd1->ampm))) {
#ifndef PAR0
#ifdef PAR
         struct NNSTR nnio;      /* nnget/nnput control block */
         byte *potf;             /* Ptr to forwarding pot */
         byte *pfe;              /* Working end of potf */
         byte *pft;              /* Top of potf */
         byte *poth;             /* Ptr to holding pot */
         byte *phe;              /* Working end of poth */
         byte *pht;              /* Top of poth */
         byte *pot,**ppe;        /* Generic pot pointers */
         long cap;               /* Partner's capacity */
         long finmask;           /* Completion mask */
#endif
#ifdef PARn
         d1s_type *pmylosi;      /* Ptr to my low cell */
         long gcn;               /* Generating cell, rel to lod1e */
#endif
         long fcr,lcr;           /* First,last cell in repertoire */
         long gcna;              /* Generating cell, absolute */
         long ngen,nrep;         /* Number generated, replaced */
         long pkeep;             /* Prob(keeping new cell) (S31) */
         long seed;              /* Amplification seed */
         long target;            /* Cell to be displaced */

#ifdef PAR
         int chan, mask, nnext;  /* Node I/O overhead */
         int cflg;               /* Node I/O and completion flag */
         int ipot;               /* Index for loop over pots */
         int litem = lnbyt + sizeof(long);
                                 /* Length of recognizer packet */
         int type;               /* Message type */
         int EffSize;            /* Effective cube size = 2**links */
         int EffChan;            /* Effective channel used with ring */
#ifndef HYPERCUBE                /* Currently implies RING */
         int HalfSize;           /* Half size of ring */
         int SesquiSize;         /* Three halves the ring size */
         int UpDown;             /* Sign of current sending */
#endif
#endif
         int ggr;                /* Generations remaining */
#endif
         int lampf = pd1->ampf;  /* Local copy of pd1->ampf */
         int lampm = pd1->ampm;  /* Local copy of pd1->ampm */
         int lampt = pd1->ampt;  /* Local copy of pd1->ampt */
#ifndef PAR0
         int lrept = pd1->rept;  /* Local copy of pd1->rept */
         int jrep;               /* Current working repertoire */
#endif
         int mxgen;              /* Max generated cells per cell */
         int nudev;              /* Number udevs per generated cell */

/* Calculate constants needed for doing udevskip:
*     mxgen = maximum number of new cells that could be generated
*                 for one cell that is being amplified
*     nudev = number of udevs done per generated cell.  */

         mxgen = (lampf + (lnbpe - lampt)*lampm) >> 8;
         if (mxgen < 0) mxgen = 0;
         if (lkd1o & KD1_MUTS) ++mxgen;
         nudev = lnbpe + 2;   /* Extras for target, pkeep */
#ifndef PAR0
         pr = pd1->pd1r;      /* Pick up rep data ptr */

/*---------------------------------------------------------------------*
*                       Parallel Amplification                         *
*---------------------------------------------------------------------*/

#ifdef PAR

/* Create pots for holding local and forwarded generated cells */
         pft = (potf = pfe = angetpv(PotSize,"D1 fwd pot")) + PotSize;
         pht = (poth = phe = angetpv(PotSize,"D1 hold pot")) + PotSize;

/* Initialize state of generating routine */
#ifdef PARn
         gcn = jrep = -1;        /* Current cell and repertoire */
         pmylosi = psi + mylo;   /* Ptr to starting cell */
#endif

/* Loop until all generated recognizers have been exchanged.  The
*  following code can handle hypercube and ring topologies.  Mask
*  finmask is sent between nodes at the end of each half-exchange.
*  The sign bit is an end signal for the half-exchange.  The right
*  NC.dim bits (hypercube) or the right 2 bits (ring) are completion
*  bits for each channel (hypercube) or link (ring).  The remaining
*  bits are ignored.  Each completion bit is set when any node has
*  data to exchange on that channel.  The mask starts out with a one
*  bit for each channel or link, unless we are doing only self-mutation
*  and no amplification.  When all bits are zero, process terminates. */

#ifdef HYPERCUBE
         EffChan = EffSize = NC.total;
#else
         EffChan = EffSize = 4;
         SesquiSize = 3*(HalfSize = NC.total>>1);
#endif
         finmask = (lampf | lampm) ? ~0 : (1-EffSize);
         type = AMPL_D1_MSG;
         while (finmask & (EffSize-1)) {
            if ((EffChan<<=1) >= EffSize) EffChan = 1;

/* For each round of exchange, each node executes the following code
*  twice, once in the role of sender and once in the role of receiver.
*  For this to work with a ring, there must be an even number of nodes.
*  This restriction is checked in d3grp1.  For the hypercube, the
*  effective channel is the same as the actual channel.  For the ring,
*  the effective channel counts partnerships, but the actual channel
*  is always 1 (partner is always adjacent around the ring).
*  Arbitrarily, the lower numbered node sends first.  */

#ifdef HYPERCUBE
            /* Partner is node at other end of current channel */
            nnext = NC.node ^ (chan = EffChan);
#else
            /* When EffChan == 1, even node pairs with next higher odd.
            *  When EffChan == 2, even node pairs with next lower odd */
            UpDown = ((EffChan ^ NC.node) & 1) ? 1 : -1;
            if (UpDown > 0) {
               nnext = NC.node + 1; if (nnext >= NC.total) nnext = 0; }
            else {
               nnext = NC.node - 1; if (nnext < 0) nnext += NC.total; }
            chan = 1;   /* Force mask loop below to execute twice */
#endif
            finmask &= ~EffChan;    /* Clear chan bit in finmask */
            /* This loop executes twice for two sending directions */
            for (mask=chan; mask>=0; mask-=chan) {
               if ((NC.node & chan) != mask) {

/*---------------------------------------------------------------------*
*                          Transmitter code                            *
*---------------------------------------------------------------------*/

                  /* Get capacity of receiver */
                  anread((char *)&cap, sizeof(long),
                     &nnext, &type, "D1 POT CAPACITY");
                  /* Make capacity a multiple of item length */
                  cap = (cap/litem)*litem;
                  /* Open a stream to the receiver */
                  nnpcr(&nnio, nnext, type);

/* Scan twice through both forwarding and holding pots.  The first
*  time, send all data from both pots for which current partner is
*  final destination.  These are not charged against receiver's
*  forwarding capacity, because they can be stored directly.  Then
*  send data from both pots for which partner is a passthrough link.
*  Send only what will fit in partner's forwarding capacity.  Set
*  cflg if there is more, indicating another pass is needed later
*  (finmask cannot be used directly because must OR with partner).  */

                  cflg = EffChan;
                  for (ipot=0; ipot<4; ipot++) {
                     /* Alternate forwarding and holding pots */
                     if (ipot & 1) pot = poth, ppe = &phe;
                     else          pot = potf, ppe = &pfe;
                     while (pot < (*ppe)) {
                        register int tnode,tdiff;
                        /* Pick up target and calc target difference */
                        memcpy((char *)&target,(char *)pot,sizeof(long));
                        tnode = Loc(target);
                        tdiff = tnode - nnext;
                        if ((ipot & 2) && (tdiff=OffPath(tnode))==0) {
                           if (cap >= litem) cap -= litem;
                           else goto EndPotCheck; /* Exit 2 loops */ }
                        if (!tdiff) {
#ifdef DEBUG
/***DEBUG***/ printf("FWD: Node %d, chan %d, target %d, string %x, case %d,"
   " sent to %d\n",NC.node,EffChan,target,((int *)pot)[1],ipot,nnext);
   fflush(stdout);
#endif
                           nnput(&nnio, pot, litem);
                           if (pot >= (*ppe -= litem)) break;
                           memcpy((char *)pot,(char *)*ppe,litem);
                           } /* End sending item */
                        else pot += litem;
                        } /* End loop over pot contents */
                     } /* End double loop over both pots */
                  cflg = 0;      /* Signal all done */
EndPotCheck:      ;              /* Here when cannot send more */

/* Generate modified recognizer cells according to amplification rule.
*  In the serial case (below), all new recognizers are simply stored
*  in their final destinations in the single memory space.  In the
*  parallel case, new recognizers that do not belong on the current
*  node must be communicated to their destination using the "pot"
*  mechanism.  Note that the global state of the generating sweep is
*  kept in the variables gcn and ggr, and generating can be restarted
*  from any point, which is necessary when a generated cell will not
*  fit in the available pot space.  This conveniently gets around the
*  absence of coroutines in C, which would be the more elegant way to
*  handle this.  As it is, we are guaranteed to go through this gene-
*  rating code at least once per channel exchange, and so the end of
*  generating will be detected even when pot space is full.  If self-
*  mutation is on, the self-mutation must be done after each cell has
*  been used as a prototype for generating, i.e., when ggr hits 0. */

#ifdef PARn       /* Node 0 has no cells to amplify */

                  /* Loop until generating is completed or blocked */
                  for (ggr=0; ; --ggr) {
                     register long ttarg; /* Temp related to target */
                     while (!ggr) {
                        /* Handle self-mutation.  (If mutfreq==0,
                        *  d3grp1 turns off KD1_MUTS bit.  d1gmrec
                        *  is not called because of self memcpy.) */
                        if (lkd1o & KD1_MUTS && gcn >= 0) {
                           int ibit;
                           byte *dest = pr + gcn*lnbyt;
                           seed = pd1->d1seed;
                           udevskip(&seed,(gcna*mxgen)*nudev);
                           for (ibit=1; ibit<=lnbpe; ibit++)
                              if (udev(&seed) < pd1->mutfreq)
                                 bitcmp(dest,ibit);
                           } /* End self-mutation */
                        /* Search for a cell with score >= ampt */
                        for (;;) {  /* Loop until break */
                           /* If no more cells, break out of 2 loops */
                           if (++gcn>=pd1->mynd1) goto EndGenLoop;
                           /* If score >= ampt, break and amplify. */
                           if (pmylosi[gcn] >= lampt) break;
                           }

/* We have found a cell to amplify.  Calculate ggr = number of copies
*  to be generated.  If entering a new repertoire, calculate total
*  number of recognizers that will be generated in the new repertoire
*  and the number of slots available to receive them.  If number gene-
*  rated exceeds number to be replaced, calculate pkeep = fraction of
*  generated recognizers to be kept (S31).  It is not necessary that
*  the number discarded exactly equal the excess.  All nodes having
*  cells in this repertoire should arrive at same value of pkeep.
*  Two values of pkeep have special meanings by convention:
*     pkeep ==  0 ==> generate all cells (no pkeep test)
*     pkeep == -1 ==> skip all generating, but scan cells for MUTS.  */

                        gcna = gcn + mylo;   /* Calc absolute cell */
                        irep = gcna/lnepr;
                        if (irep != jrep) {
                           /* Count hits in new rep */
                           fcr = irep*lnepr; /* First cell in rep */
                           lcr = fcr + lnepr; /* Last cell in rep */
                           ngen = nrep = pkeep = 0;
                           pd1->psr1 = ps1 = psi + fcr;
                           pd1->psr2 = ps2 = psi + lcr;
                           for (ps=ps1; ps<ps2; ps++) {
                              if (*ps >= lampt) ngen += AmpNum(pd1,ps);
                              if (*ps <  lrept) ++nrep;
                              }
                           /* Calculate pkeep per above notes */
                           if ((ngen == 0) || (ngen > nrep && (pkeep =
                                 ds64nq(nrep,0,-1,ngen)) == 0)) {
                              if (lkd1o & KD1_MUTS) pkeep = -1;
                              else {gcn = lcr; continue; }
                              }
                           /* Prevent counting again until next rep */
                           jrep = irep;
                           } /* End new rep code */
                        /* Calculate number to generate.  If ggr == 0
                        *  or pkeep is -1, the while loop repeats and
                        *  we try the next cell.  */
                        ggr = (pkeep >= 0) ? AmpNum(pd1,psi+gcna) : 0;
                        } /* End finding a new cell */

                     /* Update seed according to cell and ggr */
                     seed = pd1->d1seed;
                     udevskip(&seed,(gcna*mxgen+ggr)*nudev);

                     /* If not keeping all generated cells due to
                     *  excess amplif, randomly select for discard */
                     if (pkeep && udev(&seed) >= pkeep) continue;

                     /* Generate destination in current repertoire */
                     target = ((udev(&seed) % pd1->nsprd) >> 1) + 1;
                     if (seed & 1) target = -target;
                     target += gcna;   /* Get abs cell number */
                     if     (target >= lcr) target -= lnepr; /* Wrap */
                     else if (target < fcr) target += lnepr;

                     /* If target also firing, discard new cell */
                     if (psi[target] >= lrept) continue;

                     /* If target is on our node, just store it */
                     ttarg = target - mylo;
                     if (ttarg >= 0 && target < myhi) {
#ifdef DEBUG
/***DEBUG***/ int tt;
#endif
                        d1gmrec(pd1,gcn,seed,pr+ttarg*lnbyt);
#ifdef DEBUG
/***DEBUG***/ tt = *((int *)(pr + ttarg*lnbyt));
   printf("GEN: Node %d, cell %d, ggr %d, target %d,"
   " stored string %x\n",NC.node,gcna,ggr,target,tt);
   fflush(stdout);
#endif
                        }

                     /* If target is on partner node, generate and
                     *  send to partner without checking capacity. */
                     else if ((ttarg = Loc(target)) == nnext) {
                        d1gmrec(pd1,gcn,seed,pwk);
                        nnput(&nnio, (char *)&target, sizeof(target));
                        nnput(&nnio, pwk, lnbyt);
#ifdef DEBUG
/***DEBUG***/ printf("GEN: Node %d, chan %d, cell %d, ggr %d, target %d,"
   " string %x sent to partner %d\n",
   NC.node,EffChan,gcna,ggr,target,*((int *)pwk),nnext);
   fflush(stdout);
#endif
                        }

                     /* If target is on a path that passes through
                     *  partner node and partner has capacity to
                     *  store it, then generate and send to partner. */
                     else if (!OffPath(ttarg)) {
                        if (cap < litem) break;
                        cap -= litem;
                        d1gmrec(pd1,gcn,seed,pwk);
                        nnput(&nnio, (char *)&target, sizeof(target));
                        nnput(&nnio, pwk, lnbyt);
#ifdef DEBUG
/***DEBUG***/ printf("GEN: Node %d, chan %d, cell %d, ggr %d, target %d,"
   " string %x sent via partner %d\n",
   NC.node,EffChan,gcna,ggr,target,*((int *)pwk),nnext);
   fflush(stdout);
#endif
                        }

                     /* If there is room in our own holding pot,
                     *  put it there.  */
                     else if ((pot = phe + litem) <= pht) {
                        memcpy(phe,&target,sizeof(target));
                        d1gmrec(pd1,gcn,seed,phe+sizeof(target));
#ifdef DEBUG
/***DEBUG***/ printf("GEN: Node %d, chan %d, cell %d, ggr %d, target %d,"
   " string %x held\n",
   NC.node,EffChan,gcna,ggr,target,((int *)phe)[1]);
   fflush(stdout);
#endif
                        phe = pot;
                        }

                     /* Otherwise, advance to next channel */
                     else break;

                     } /* End generating loop */
                  cflg |= EffChan;  /* Indicate another pass needed */
EndGenLoop:       ;              /* Here when generating complete */

#endif            /* End host exclusion */

/* Send completion mask to partner and close output stream */

                  finmask |= cflg;
                  nnput(&nnio, (char *)&finmask, sizeof(finmask));
                  nnpcl(&nnio);  /* Close output stream */
                  } /* End sender code */

/*---------------------------------------------------------------------*
*                            Receiver code                             *
*---------------------------------------------------------------------*/

               else {

                  /* Calculate capacity of my forwarding pot */
                  cap = pft - pfe;
                  /* Send capacity to sending partner */
                  anwrite((char *)&cap, sizeof(long),
                     nnext, type, "D1 POT CAPACITY");
                  /* Open a stream from sending partner */
                  nngcr(&nnio, nnext, type);

/* Receive destination/recognizer items from sender.  If my node is
*  the final destination, move the cell to my repertoire storage.
*  Otherwise, move it to my forwarding pot.  It is not necessary to
*  check for room in the pot, because sender will not exceed capacity
*  sent to him by above anwrite.  A negative destination is the end
*  signal, which also contains sender's finmask.  OR it with mine. */

                  for (;;) {
                     nnget(&nnio, (char *)&target, sizeof(long));
                     if (target < 0) break;
                     if (Loc(target) == NC.node) {
#ifdef DEBUG
/***DEBUG***/ int tt;
#endif
                        nnget(&nnio, pr + (target-mylo)*lnbyt, lnbyt);
#ifdef DEBUG
/***DEBUG***/ tt = *((int *)(pr + (target-mylo)*lnbyt));
   printf("RCV: Node %d, chan %d, target %d, string %x stored\n",
   NC.node,EffChan,target,tt);
   fflush(stdout);
#endif
                        }
                     else {      /* Save in forwarding pot */
                        memcpy((char *)pfe, (char *)&target, sizeof(target));
                        nnget(&nnio, pfe + sizeof(target), lnbyt);
#ifdef DEBUG
/***DEBUG***/ printf("RCV: Node %d, chan %d, target %d, string %x held for fwd\n",
   NC.node,EffChan,target,((int *)pfe)[1]);
   fflush(stdout);
#endif
                        pfe += litem;
                        }
                     } /* End receive loop */

                  finmask |= target;
                  nngcl(&nnio);  /* Close input stream */
                  } /* End receiver code */

               } /* End two passes through send/receive code */
            } /* End while finmask */

         /* Free pot buffers */
         anrelp(potf);
         anrelp(poth);

/*---------------------------------------------------------------------*
*                        Serial Amplification                          *
*---------------------------------------------------------------------*/

#else    /* Perform serial amplification */

         /* Loop over repertoires */
         ps2 = psi;
         for (irep=0; irep<pd1->nd1r; irep++) {
            pd1->psr1 = ps1 = ps2;
            pd1->psr2 = (ps2 += lnepr);
            fcr = ps1 - psi; lcr = fcr + lnepr;

/* Calculate total number of recognizers that will be generated in
*  this repertoire and the number of slots available to receive them.
*  If number generated exceeds number to be replaced, calculate frac-
*  tion of generated recognizers to be discarded.  It is not necessary
*  that the number discarded exactly equal the excess.  */

            ngen = nrep = pkeep = 0;
            for (ps=ps1; ps<ps2; ps++) {
               if (*ps >= (unsigned)lampt) ngen += AmpNum(pd1,ps);
               if (*ps <  (unsigned)lrept) ++nrep;
               }
            /* Make probability of keeping new cell (S31).
            *  If nothing would be kept, but there is self-mutation,
            *  set pkeep = -1 to indicate this fact.  If there is no
            *  self-mutation, advance to next repertoire.
            *  Otherwise, (pkeep == 0) ==> keep all new cells. */
            if ((ngen == 0) || (ngen > nrep &&
                  (pkeep = ds64nq(nrep,0,-1,ngen)) == 0)) {
               if (lkd1o & KD1_MUTS) pkeep = -1;
               else continue;
               }

/* Loop over cells in current repertoire */

            for (ps=ps1; ps<ps2; ps++) {

               /* If score less than amp threshold, skip cell */
               if (*ps < (unsigned)lampt) continue;

               /* Got one.  Calc number of copies to generate. */
               gcna = ps - psi;
               ggr = (pkeep >= 0) ? AmpNum(pd1,ps) : 0;

               /* Loop to generate mutated recognizers */
               for ( ; ggr; ggr--) {

                  /* Update seed according to cell number */
                  seed = pd1->d1seed;
                  udevskip(&seed,(gcna*mxgen+ggr)*nudev);

                  /* If not keeping all generated cells due to
                  *  excess amplif, randomly select for discard */
                  if (pkeep && udev(&seed) >= pkeep) continue;

                  /* Generate destination in current repertoire */
                  target = ((udev(&seed) % pd1->nsprd) >> 1) + 1;
                  if (seed & 1) target = -target;
                  target += gcna;   /* Get abs cell number */
                  if     (target >= lcr) target -= lnepr; /* Wrap */
                  else if (target < fcr) target += lnepr;

                  /* If target also firing, discard new cell */
                  if (psi[target] >= (unsigned)lrept) continue;

                  /* Generate and store new cell */
                  d1gmrec(pd1,gcna,seed,pr+target*lnbyt);
                  } /* End ggr loop */

               /* Handle self-mutation */
               if (lkd1o & KD1_MUTS) {
                  int ibit;
                  byte *dest = pr + gcna*lnbyt;
                  seed = pd1->d1seed;
                  udevskip(&seed,(gcna*mxgen)*nudev);
                  for (ibit=1; ibit<=lnbpe; ibit++)
                     if (udev(&seed) < pd1->mutfreq)
                        bitcmp(dest,ibit);
                  } /* End self-mutation */

               } /* End loop over cells */
            } /* End repertoire loop */

#endif   /* End serial amplification */

         /* Advance seed on all nodes for next cycle */
#endif /* ifndef PAR0 */
         udevskip(&pd1->d1seed,nelt*mxgen*nudev);
         } /* End amplification */

      stattmr(OP_POP_TMR,0);
      } /* End loop over D1 blocks */

   } /* End d1go */
