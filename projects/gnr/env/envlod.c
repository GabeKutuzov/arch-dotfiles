/* (c) Copyright 1989-2010, The Rockefeller University *21115* */
/* $Id: envlod.c 23 2017-01-16 19:28:30Z  $ */
/***********************************************************************
*              Darwin III Environment Simulation Package               *
*                               ENVLOD                                 *
*                                                                      *
*  Loads a shape into a created object record.  Desired shape is       *
*  identified by a "handle" generated by ENVLOC.  In the case of a     *
*  library object, loading the object is accomplished by dynamically   *
*  allocating space for it and reading it in from the direct-access    *
*  library file.  In the case of a user-loaded object, if the size     *
*  of the item is not being changed, a pointer to the item is placed   *
*  in the PSHAPE field.  Otherwise a new record is built and desired   *
*  subset of the data is moved.  Space for a new record is dynamically *
*  allocated only if there is no existing previously allocated record  *
*  of equal or greater size (current record size kept in SHPSIZ).      *
*                                                                      *
*  Note: Items with formats 0 or 4 (bit arrays) are expanded into      *
*        pixel arrays.  This is to save time in ENVPIA, which must     *
*        be executed each cycle.  The disadvantages are that a         *
*        larger DSLB is needed (shouldn't be many of these) and        *
*        hi/lo pixel values cannot be changed once an object has       *
*        been created (could actually be advantageous).                *
*                                                                      *
*  Synopsis: int envlod(struct ENVDEF *Eptr,OBJECT *Obj, struct        *
*     LIBHANDLE *handle,short tux, short tuy)                          *
*     Eptr:    Ptr to current environment                              *
*     Obj:     Ptr to object record for item                           *
*     handle:  Ptr to shape locator as described above                 *
*     tux,tuy: used x,y size                                           *
************************************************************************
*  V4A, 01/08/89, JWT - Translated into C                              *
*  Rev, 03/04/92, GNR - Use rf io routines                             *
*  Rev, 08/09/92, GNR - Introduce LIBHANDLE for portability            *
*  Rev, 10/29/93, GNR - Correct fmt 0 storage bug, remove DSLB.u1      *
*  Rev, 02/10/97, GNR - Make library file always big-endian            *
*  Rev, 05/22/99, GNR - Use new swapping scheme                        *
*  Rev, 08/15/00, GNR - Correct bug reading SHAPE when tux==tuy==0     *
*  ==>, 02/22/03, GNR - Last mod before committing to svn repository   *
*  V8H, 12/01/10, GNR - Separate env.h,envglob.h w/ECOLMAXCH change    *
***********************************************************************/

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sysdef.h"
#include "swap.h"
#include "envglob.h"
#include "rocks.h"
#include "bapkg.h"

#define LBBUFF  80            /* Length of bit unpacking buffer */
#define LBBIT   (LBBUFF<<3)   /* Length in bits */
#define LBBITP1 (LBBIT + 1)

#define library_item(H) ((H)->pmemsh == 0)
#define bit_format(fmt) (!((fmt)&3))

int envlod(struct ENVDEF *Eptr, struct OBJDEF *Obj,
      LIBHANDLE *handle, short tux, short tuy) {

   struct RFdef *plib = Eptr->libfile; /* Shape library file  */
   struct DSLBDEF *ip;        /* Ptr to new shape record      */
   struct DSLBDEF *shptr;     /* Ptr to user item from handle */
   byte bbuff[LBBUFF];        /* Buffer for unpacking bits    */
   stim_type *ppix;           /* Pointer to pixels at ip      */
   byte *pshp;                /* Pointer to pixels at shptr   */
   long  ts;                  /* Object area (X*Y)            */
   long  ldsb;                /* Memory allocation size       */
   long  ix,iy;               /* Loop counters                */
   int   ib;                  /* Offset into src pixel array  */
   short libsy;               /* Y size of library shape      */

   /* Local copies of shape record fields (DSLB) */
   char nshp1[SHP_NAME_SIZE];
   ui16 tgp1;
   short tsx1,tsy1,tfm1;

/* If item is in library file, locate record in index
*  and read header info.  */

   if (library_item(handle)) {
      size_t shprec = Eptr->plibid[handle->libsh].recnum;
      rfseek(plib,shprec*LIB_REC_SIZE,SEEKABS,ABORT);
      rfread(plib,nshp1,SHP_NAME_SIZE,ABORT);
      tgp1 = rfri2(plib);
      tfm1 = rfri2(plib);
      tsx1 = rfri2(plib);
      tsy1 = rfri2(plib);

/* Determine size to be used = smaller of (tsx1,tsy1) or (tux,tuy) */

      libsy = tsy1;
      if (tux) tsx1 = min(tsx1,tux);
      if (tuy) tsy1 = min(tsy1,tuy);

/* Allocate a new record or re-use a previous one.
*  Note: This code will never store a library item over a user-
*        entered item, because replacement only occurs with SELECT
*        items, which must (at this time) be library items.  If
*        this changes, a flag must be set to indicate if the
*        current PSHAPE points to a user item.  SHPSIZ = 0 is not
*        a valid indicator of this condition, as demonstrated by
*        this sequence of events:
*           1) Library item (SHPSIZ set != 0)
*           2) User item (PSHAPE points to user item)
*           3) Library item (tries to read into record at PSHAPE)
*/
      ts = tsx1*tsy1;
      ldsb = ts + sizeof(struct DSLBDEF);
      if (Obj->shpsiz < ldsb) {
         if (Obj->shpsiz > 0) free(Obj->pshape);
         Obj->pshape = (struct DSLBDEF *)mallocv(ldsb,"ENVLOD: shape");
         Obj->shpsiz = ldsb;
         }

/* Move name, format, and size info into new record */

      ip = Obj->pshape;
      strncpy(ip->nshp,nshp1,SHP_NAME_SIZE);
      ip->tgp = tgp1;
      ip->tfm = tfm1;
      ip->tsx = tsx1;
      ip->tsy = tsy1;

/* Read pixel data... broken into three cases:
*     1) Formats 0 and 4 (expand bits into pixels).
*     2) Formats 1, 2, and 3 (where data already stored as pixels)
*        with no y-size change--data can be read in one shot.
*     3) Formats 1, 2, and 3 with y-size being reduced (data must
*        be read column by column).
*/

      ppix = (stim_type *)dslpix(ip);
      if (bit_format(tfm1)) {
         /* Bit array must be mapped to pixels.  A separate bit buffer
         *  (bbuff) is used for unpacking.  ib = bit to be unpacked
         *  next.  Note:  It is not too inefficient to make bbuff
         *  small (LBBUFF = 80), as most of the time is spent
         *  unpacking anyway.  */
         short recl = (ts+7)>>3;
         ib = LBBIT;          /* Triggers first read */
         for (ix=0; ix<tsx1; ix++) {
            /* Unpack bits for one column */
            for (iy=0; iy<tsy1; iy++) {
               /* Read another buffer when contents all unpacked */
               if (++ib > LBBIT) {
                  long lread = min(LBBUFF,recl);
                  recl -= lread;
                  rfread(plib,bbuff,lread,ABORT);
                  ib -= LBBIT;   }
               *ppix++ = (bittst(bbuff,(long)ib) ?
                  Eptr->eihi : Eptr->eilo);
               } /* End loop over Y */

            /* End of column... execute skip if required */
            if ((tsy1 < libsy) && ((ib += libsy - tsy1) > LBBIT)) {
               rfseek(plib,(ib-LBBITP1)>>3,SEEKREL,ABORT);
               ib = LBBITP1; }
            } /* End loop over X */
         } /* End bit format (case 1) */

      else if (libsy == tsy1) /* Case 2 (format 1-3 with no Y change) */
         rfread(plib, ppix, ts, ABORT);

      else {               /* Case 3 (format 1-3 with Y-size change) */
         long skipcnt = libsy - tsy1;
         for (ix=0; ix<tsx1; ppix+=tsy1,ix++) {
            rfread(plib,ppix,tsy1,ABORT);
            rfseek(plib,skipcnt,SEEKREL,ABORT);
            }
         } /* End case 3 */
      return ENV_NORMAL;
      } /* End library item */

/*---------------------------------------------------------------------*
*                                                                      *
*                      Handle user-entered items                       *
*                                                                      *
*  If the full item is to be used and no unpacking (bit-to-pixel) is   *
*    required, we only need to store a ptr to the object in PSHAPE.    *
*                                                                      *
*  SHPSIZ = 0 will indicate the item space is not to be FREE'd upon    *
*    deletion                                                          *
*                                                                      *
*---------------------------------------------------------------------*/

   shptr = handle->pmemsh;
   Obj->objflag |= OBJUO;
   tsx1 = shptr->tsx;
   tsy1 = shptr->tsy;
   tfm1 = shptr->tfm;
   if (tfm1 && (tux==0 || tux>=tsx1) && (tuy==0 || tuy>=tsy1)) {
      Obj->pshape = shptr;
      return ENV_NORMAL;
      }

/* Determine size to be used = smaller of (tsx1,tsy1) and (tux,tuy).
*  Leave size stored in (tsx1,tsy1) for combined comparison later
*  (still have to do separate X,Y compares since one coord larger,
*  one smaller than (tux,tuy) is possible  */

   libsy = tsy1;
   if (tux) tsx1 = min(tsx1,tux);
   if (tuy) tsy1 = min(tsy1,tuy);

/* Allocate new record or re-use previous one */

   ts = tsx1*tsy1;
   ldsb = ts + sizeof(struct DSLBDEF);
   if (Obj->shpsiz < ldsb) {
      if (Obj->shpsiz > 0) free(Obj->pshape);
      Obj->pshape = (struct DSLBDEF *)mallocv(ldsb,"ENVLOD: new shape");
      Obj->shpsiz = ldsb;
      }

/* Move name, format, and size info into new record */

   ip = Obj->pshape;
   *ip = *shptr;

/* Move pixel data (same 3 cases as with library objects) */

   ppix = (stim_type *)dslpix(ip);
   pshp = (byte *)dslpix(shptr);
   if (bit_format(tfm1)) {
      /* Case 1 (format 0 or 4... map bits to pixels) */
      long skipcnt = libsy - tsy1;
      ib = 0;
      for (ix=0; ix<tsx1; ib+=skipcnt,ix++) {
      /* Unpack bits for one column */
         for (iy=0; iy<tsy1; iy++) {
            *ppix++ = bittst(pshp,++ib) ? Eptr->eihi : Eptr->eilo;
            } /* End inner for */
         } /* End outer for */
      } /* End case 1 */

   else if (libsy == tsy1) {
      /* Case 2 (format 1-3 and no y-size change) */
      memcpy((char *)ppix,(char *)pshp,ts);
      }

   else {
      /* Case 3 (format 1-3 with y-size change) */
      for (ix=0; ix<tsx1; ppix+=tsy1,pshp+=libsy,ix++)
         memcpy((char *)ppix,(char *)pshp,tsy1);
      } /* End case 3 */

   return ENV_NORMAL;
   } /* End envlod */

